#!/bin/bash
set -euo pipefail

# ==============================================================================
# LXD Panel v2 (Panel-first + Node enroll/pair_token)
# ------------------------------------------------------------------------------
# One script, two modes:
#   MODE=panel  -> install central Panel (auth + node registry + proxy)
#   MODE=node   -> install Node-Agent on an LXD host and enroll into the Panel
#
# Examples:
#   # 1) Install Panel (central)
#   MODE=panel API_PORT=9876 ./install-v2.sh
#
#   # 2) On each LXD host, install Node-Agent and enroll
#   MODE=node PANEL_URL="http://PANEL_IP:9876" PAIR_TOKEN="xxxxx" NODE_PORT=19876 ./install-v2.sh
#
# What you get:
#   - Panel always logins first (doesn't depend on nodes)
#   - Node pairing/enroll replaces "paste huge bundle"
#   - Panel proxies requests to nodes: /nodes/{id}/...
#   - Node exposes LXD mgmt: create/reinstall/limits/portpool/proxy devices/bandwidth tc
#   - Container Linux user management: create user + SSH key
#
# Security notes (practical):
#   - Panel auth: JWT (admin only in this v2, easy to extend RBAC later)
#   - Node auth: Panel-to-node shared secret (stored in DB; sent as X-Node-Secret)
#   - Strongly recommended: put Panel behind Nginx+mTLS or VPN
# ==============================================================================

RED='\033[0;31m'; GREEN='\033[0;32m'; YELLOW='\033[0;33m'; BLUE='\033[0;36m'; PLAIN='\033[0m'
info(){ echo -e "${BLUE}[INFO]${PLAIN} $*"; }
ok(){ echo -e "${GREEN}[OK]${PLAIN} $*"; }
warn(){ echo -e "${YELLOW}[WARN]${PLAIN} $*"; }
die(){ echo -e "${RED}[ERR]${PLAIN} $*"; exit 1; }

[[ $EUID -eq 0 ]] || die "Run as root"

export DEBIAN_FRONTEND=noninteractive

MODE="${MODE:-panel}"              # panel | node
API_PORT="${API_PORT:-9876}"       # Panel port
NODE_PORT="${NODE_PORT:-19876}"    # Node-Agent port
BIND_ADDR="${BIND_ADDR:-0.0.0.0}"

# Panel enrollment (only for MODE=node)
PANEL_URL="${PANEL_URL:-}"
PAIR_TOKEN="${PAIR_TOKEN:-}"

# Port pools (per node)
PORT_MIN="${PORT_MIN:-20000}"
PORT_MAX="${PORT_MAX:-40000}"
DEFAULT_PROFILE="${DEFAULT_PROFILE:-default}"

# Paths
BASE="/opt/lxd-panel-v2"
PANEL_DIR="${BASE}/panel"
NODE_DIR="${BASE}/node"
CFG_DIR="/etc/lxd-panel-v2"
DATA_DIR="/var/lib/lxd-panel-v2"
LOG_DIR="/var/log/lxd-panel-v2"

rand_pw(){ tr -dc 'A-Za-z0-9_@#%+=' </dev/urandom | head -c 20; }
rand_hex(){ tr -dc 'a-f0-9' </dev/urandom | head -c "${1:-32}"; }

need_cmd(){ command -v "$1" >/dev/null 2>&1; }

detect_lxd_socket() {
  local s1="/var/lib/lxd/unix.socket"
  local s2="/var/snap/lxd/common/lxd/unix.socket"
  [[ -S "$s1" ]] && { echo "$s1"; return; }
  [[ -S "$s2" ]] && { echo "$s2"; return; }
  echo "$s1"
}

install_pkgs_common() {
  info "Installing base packages..."
  apt-get update -y
  apt-get install -y curl ca-certificates gnupg jq sqlite3 iproute2 iptables \
    python3 python3-venv python3-pip uidmap
  ok "Base packages installed."
}

install_lxd_if_needed() {
  if ! need_cmd lxc; then
    info "Installing LXD (apt)..."
    apt-get install -y lxd
  else
    ok "LXD already installed."
  fi
}

init_lxd_if_needed() {
  info "Checking LXD..."
  if ! lxc info >/dev/null 2>&1; then
    warn "LXD not initialized. Running 'lxd init --auto' (safe default)..."
    lxd init --auto >/dev/null
  fi
  ok "LXD ready. socket=$(detect_lxd_socket)"
}

mk_dirs() {
  mkdir -p "$BASE" "$CFG_DIR" "$DATA_DIR" "$LOG_DIR"
  chmod 750 "$DATA_DIR" "$LOG_DIR" || true
}

# ------------------------------------------------------------------------------
# PANEL APP (central)
# ------------------------------------------------------------------------------
write_panel_app() {
  info "Writing Panel app..."
  mkdir -p "${PANEL_DIR}/app"

  cat > "${PANEL_DIR}/requirements.txt" << 'REQ'
fastapi==0.115.6
uvicorn[standard]==0.30.6
pyjwt==2.9.0
passlib[bcrypt]==1.7.4
pydantic==2.10.3
httpx==0.27.2
REQ

  cat > "${PANEL_DIR}/app/main.py" << 'PY'
import os, json, sqlite3, secrets, time
from datetime import datetime, timedelta
from typing import Optional, Dict, Any, List

import jwt
import httpx
from fastapi import FastAPI, HTTPException, Depends, Request
from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials
from pydantic import BaseModel, Field
from passlib.context import CryptContext

APP_NAME="lxd-panel-v2"
DB_PATH=os.getenv("PANEL_DB","/var/lib/lxd-panel-v2/panel.db")
JWT_SECRET=os.getenv("PANEL_JWT_SECRET","change-me")
JWT_ISSUER=os.getenv("PANEL_JWT_ISSUER","lxd-panel-v2")
JWT_EXPIRE_MIN=int(os.getenv("PANEL_JWT_EXPIRE_MIN","1440"))
ADMIN_USER=os.getenv("PANEL_ADMIN_USER","admin")
ADMIN_PASS=os.getenv("PANEL_ADMIN_PASS","")

pwd=CryptContext(schemes=["bcrypt"], deprecated="auto")
bearer=HTTPBearer(auto_error=False)

app=FastAPI(title="LXD Panel v2", version="2.0.0")

def db():
    c=sqlite3.connect(DB_PATH)
    c.row_factory=sqlite3.Row
    return c

def init_db():
    c=db()
    cur=c.cursor()
    cur.execute("""
    CREATE TABLE IF NOT EXISTS users(
      username TEXT PRIMARY KEY,
      password_hash TEXT NOT NULL,
      role TEXT NOT NULL,
      created_at TEXT NOT NULL
    )""")
    cur.execute("""
    CREATE TABLE IF NOT EXISTS nodes(
      id TEXT PRIMARY KEY,
      name TEXT NOT NULL,
      url TEXT NOT NULL,
      secret TEXT NOT NULL,
      created_at TEXT NOT NULL,
      last_seen TEXT
    )""")
    cur.execute("""
    CREATE TABLE IF NOT EXISTS pair_tokens(
      token TEXT PRIMARY KEY,
      expires_at INTEGER NOT NULL,
      used INTEGER NOT NULL DEFAULT 0,
      created_at TEXT NOT NULL
    )""")
    cur.execute("""
    CREATE TABLE IF NOT EXISTS audit(
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      ts TEXT NOT NULL,
      actor TEXT NOT NULL,
      action TEXT NOT NULL,
      detail TEXT NOT NULL
    )""")
    c.commit()
    c.close()

def audit(actor:str, action:str, detail:Dict[str,Any]):
    c=db()
    c.execute("INSERT INTO audit(ts,actor,action,detail) VALUES(?,?,?,?)",
              (datetime.utcnow().isoformat()+"Z", actor, action, json.dumps(detail, ensure_ascii=False)))
    c.commit(); c.close()

def ensure_admin():
    if not ADMIN_PASS:
        return
    c=db()
    r=c.execute("SELECT username FROM users WHERE username=?", (ADMIN_USER,)).fetchone()
    if not r:
        c.execute("INSERT INTO users(username,password_hash,role,created_at) VALUES(?,?,?,?)",
                  (ADMIN_USER, pwd.hash(ADMIN_PASS), "admin", datetime.utcnow().isoformat()+"Z"))
        c.commit()
    c.close()

@app.on_event("startup")
def _startup():
    init_db()
    ensure_admin()

def mk_token(username:str, role:str)->str:
    now=datetime.utcnow()
    payload={"iss":JWT_ISSUER,"sub":username,"role":role,"iat":int(now.timestamp()),
             "exp":int((now+timedelta(minutes=JWT_EXPIRE_MIN)).timestamp())}
    return jwt.encode(payload, JWT_SECRET, algorithm="HS256")

def verify(creds: Optional[HTTPAuthorizationCredentials]) -> Dict[str,Any]:
    if not creds:
        raise HTTPException(401,"Missing Authorization")
    try:
        return jwt.decode(creds.credentials, JWT_SECRET, algorithms=["HS256"])
    except Exception:
        raise HTTPException(401,"Invalid token")

def require_admin(payload=Depends(lambda c=Depends(bearer): verify(c))):
    if payload.get("role")!="admin":
        raise HTTPException(403,"Admin only")
    return payload

class LoginReq(BaseModel):
    username:str
    password:str

@app.get("/health")
def health():
    return {"ok":True,"name":APP_NAME,"ts":datetime.utcnow().isoformat()+"Z"}

@app.post("/auth/login")
def login(req:LoginReq):
    c=db()
    r=c.execute("SELECT username,password_hash,role FROM users WHERE username=?", (req.username,)).fetchone()
    c.close()
    if not r or not pwd.verify(req.password, r["password_hash"]):
        raise HTTPException(401,"Bad credentials")
    t=mk_token(r["username"], r["role"])
    audit(r["username"],"login",{"username":r["username"]})
    return {"token":t,"role":r["role"]}

# ---------------- Pair token flow ----------------
class PairTokenResp(BaseModel):
    token:str
    expires_in:int

@app.post("/nodes/pair_token", response_model=PairTokenResp, dependencies=[Depends(require_admin)])
def create_pair_token(ttl_seconds:int=600, payload=Depends(require_admin)):
    ttl_seconds=max(60, min(ttl_seconds, 3600))
    token=secrets.token_urlsafe(24)
    exp=int(time.time())+ttl_seconds
    c=db()
    c.execute("INSERT INTO pair_tokens(token,expires_at,used,created_at) VALUES(?,?,0,?)",
              (token, exp, datetime.utcnow().isoformat()+"Z"))
    c.commit(); c.close()
    audit(payload["sub"],"pair_token.create",{"ttl":ttl_seconds})
    return PairTokenResp(token=token, expires_in=ttl_seconds)

class EnrollReq(BaseModel):
    token:str
    name:str = Field(..., min_length=1, max_length=64)
    url:str  = Field(..., min_length=5, max_length=256) # e.g. http://nodeip:19876

class EnrollResp(BaseModel):
    node_id:str
    node_secret:str

@app.post("/nodes/enroll", response_model=EnrollResp)
def enroll(req:EnrollReq, request:Request):
    now=int(time.time())
    c=db()
    t=c.execute("SELECT token,expires_at,used FROM pair_tokens WHERE token=?", (req.token,)).fetchone()
    if not t:
        c.close()
        raise HTTPException(403,"Invalid pair token")
    if int(t["used"])==1:
        c.close()
        raise HTTPException(403,"Pair token already used")
    if now>int(t["expires_at"]):
        c.close()
        raise HTTPException(403,"Pair token expired")

    node_id=secrets.token_hex(8)
    node_secret=secrets.token_urlsafe(32)
    c.execute("UPDATE pair_tokens SET used=1 WHERE token=?", (req.token,))
    c.execute("INSERT INTO nodes(id,name,url,secret,created_at,last_seen) VALUES(?,?,?,?,?,?)",
              (node_id, req.name, req.url.rstrip("/"), node_secret, datetime.utcnow().isoformat()+"Z", None))
    c.commit(); c.close()
    audit("node-enroll","node.enroll",{"node_id":node_id,"name":req.name,"url":req.url,"from":request.client.host if request.client else None})
    return EnrollResp(node_id=node_id, node_secret=node_secret)

# ---------------- Nodes management ----------------
@app.get("/nodes", dependencies=[Depends(require_admin)])
def list_nodes(payload=Depends(require_admin)):
    c=db()
    rows=c.execute("SELECT id,name,url,created_at,last_seen FROM nodes ORDER BY created_at DESC").fetchall()
    c.close()
    return {"nodes":[dict(r) for r in rows]}

@app.get("/nodes/{node_id}/health", dependencies=[Depends(require_admin)])
async def node_health(node_id:str, payload=Depends(require_admin)):
    c=db()
    n=c.execute("SELECT id,url,secret FROM nodes WHERE id=?", (node_id,)).fetchone()
    c.close()
    if not n: raise HTTPException(404,"Node not found")
    async with httpx.AsyncClient(timeout=6) as client:
        r=await client.get(f"{n['url']}/node/health", headers={"X-Node-Secret":n["secret"]})
    if r.status_code!=200:
        raise HTTPException(502,f"Node unhealthy: {r.text}")
    c=db()
    c.execute("UPDATE nodes SET last_seen=? WHERE id=?", (datetime.utcnow().isoformat()+"Z", node_id))
    c.commit(); c.close()
    return r.json()

# ---------------- Proxy to node ----------------
# All node calls go through panel:
#   /nodes/{id}/instances ...
#   /nodes/{id}/ports ...
# Panel adds X-Node-Secret automatically
@app.api_route("/nodes/{node_id}/{path:path}", methods=["GET","POST","PUT","PATCH","DELETE"], dependencies=[Depends(require_admin)])
async def proxy(node_id:str, path:str, request:Request, payload=Depends(require_admin)):
    c=db()
    n=c.execute("SELECT url,secret FROM nodes WHERE id=?", (node_id,)).fetchone()
    c.close()
    if not n:
        raise HTTPException(404,"Node not found")

    # Build target URL
    target=f"{n['url'].rstrip('/')}/{path.lstrip('/')}"
    method=request.method.upper()

    # Copy query & body
    params=dict(request.query_params)
    body=await request.body()
    headers={}
    # minimal forwarded headers
    if request.headers.get("content-type"):
        headers["content-type"]=request.headers["content-type"]
    headers["X-Node-Secret"]=n["secret"]

    async with httpx.AsyncClient(timeout=60) as client:
        r=await client.request(method, target, params=params, content=body, headers=headers)

    audit(payload["sub"],"node.proxy",{"node_id":node_id,"method":method,"path":path,"status":r.status_code})
    # pass-through response
    try:
        return r.json()
    except Exception:
        return {"status":r.status_code,"text":r.text}

@app.get("/audit", dependencies=[Depends(require_admin)])
def get_audit(limit:int=200, payload=Depends(require_admin)):
    c=db()
    rows=c.execute("SELECT * FROM audit ORDER BY id DESC LIMIT ?", (int(limit),)).fetchall()
    c.close()
    return {"audit":[dict(r) for r in rows]}
PY

  cat > "${PANEL_DIR}/app/bootstrap.py" << 'PY'
import os, sqlite3
from datetime import datetime
from passlib.context import CryptContext

DB=os.getenv("PANEL_DB","/var/lib/lxd-panel-v2/panel.db")
ADMIN_USER=os.getenv("PANEL_ADMIN_USER","admin")
ADMIN_PASS=os.getenv("PANEL_ADMIN_PASS","")

pwd=CryptContext(schemes=["bcrypt"], deprecated="auto")

def db():
    c=sqlite3.connect(DB)
    c.row_factory=sqlite3.Row
    return c

def init_db():
    c=db()
    cur=c.cursor()
    cur.execute("""CREATE TABLE IF NOT EXISTS users(
      username TEXT PRIMARY KEY,
      password_hash TEXT NOT NULL,
      role TEXT NOT NULL,
      created_at TEXT NOT NULL
    )""")
    cur.execute("""CREATE TABLE IF NOT EXISTS nodes(
      id TEXT PRIMARY KEY,
      name TEXT NOT NULL,
      url TEXT NOT NULL,
      secret TEXT NOT NULL,
      created_at TEXT NOT NULL,
      last_seen TEXT
    )""")
    cur.execute("""CREATE TABLE IF NOT EXISTS pair_tokens(
      token TEXT PRIMARY KEY,
      expires_at INTEGER NOT NULL,
      used INTEGER NOT NULL DEFAULT 0,
      created_at TEXT NOT NULL
    )""")
    cur.execute("""CREATE TABLE IF NOT EXISTS audit(
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      ts TEXT NOT NULL,
      actor TEXT NOT NULL,
      action TEXT NOT NULL,
      detail TEXT NOT NULL
    )""")
    c.commit(); c.close()

def ensure_admin():
    if not ADMIN_PASS:
        return
    c=db()
    r=c.execute("SELECT username FROM users WHERE username=?", (ADMIN_USER,)).fetchone()
    if not r:
        c.execute("INSERT INTO users(username,password_hash,role,created_at) VALUES(?,?,?,?)",
                  (ADMIN_USER, pwd.hash(ADMIN_PASS), "admin", datetime.utcnow().isoformat()+"Z"))
        c.commit()
    c.close()

if __name__=="__main__":
    os.makedirs(os.path.dirname(DB), exist_ok=True)
    init_db()
    ensure_admin()
PY

  ok "Panel app written."
}

panel_venv() {
  info "Setting up Panel venv..."
  python3 -m venv "${PANEL_DIR}/venv"
  "${PANEL_DIR}/venv/bin/pip" install --upgrade pip >/dev/null
  "${PANEL_DIR}/venv/bin/pip" install -r "${PANEL_DIR}/requirements.txt" >/dev/null
  ok "Panel deps installed."
}

write_panel_env() {
  info "Writing Panel env..."
  local admin_pass jwt_secret
  admin_pass="$(rand_pw)"
  jwt_secret="$(rand_hex 48)"

  cat > "${CFG_DIR}/panel.env" << EOF
PANEL_DB=${DATA_DIR}/panel.db
PANEL_ADMIN_USER=admin
PANEL_ADMIN_PASS=${admin_pass}
PANEL_JWT_SECRET=${jwt_secret}
PANEL_JWT_ISSUER=lxd-panel-v2
PANEL_JWT_EXPIRE_MIN=1440
EOF
  chmod 600 "${CFG_DIR}/panel.env"
  echo "$admin_pass" > "${CFG_DIR}/panel.admin.pass"
  chmod 600 "${CFG_DIR}/panel.admin.pass"
  ok "Panel env ready at ${CFG_DIR}/panel.env"
}

bootstrap_panel_db() {
  info "Bootstrapping Panel DB..."
  set +u
  # shellcheck disable=SC1090
  source "${CFG_DIR}/panel.env"
  set -u
  "${PANEL_DIR}/venv/bin/python" "${PANEL_DIR}/app/bootstrap.py"
  ok "Panel DB initialized."
}

write_panel_systemd() {
  info "Writing Panel systemd..."
  cat > /etc/systemd/system/lxd-panel.service << EOF
[Unit]
Description=LXD Panel v2 (central)
After=network.target

[Service]
Type=simple
EnvironmentFile=${CFG_DIR}/panel.env
WorkingDirectory=${PANEL_DIR}
ExecStart=${PANEL_DIR}/venv/bin/uvicorn app.main:app --host ${BIND_ADDR} --port ${API_PORT} --proxy-headers
Restart=always
RestartSec=2
User=root
NoNewPrivileges=true
PrivateTmp=true
ProtectHome=true
ProtectSystem=full
ReadWritePaths=${DATA_DIR} ${LOG_DIR} ${CFG_DIR} ${PANEL_DIR}

[Install]
WantedBy=multi-user.target
EOF
  systemctl daemon-reload
  systemctl enable lxd-panel >/dev/null
  systemctl restart lxd-panel
  ok "Panel service started: lxd-panel"
}

# ------------------------------------------------------------------------------
# NODE APP (LXD host agent)
# ------------------------------------------------------------------------------
write_node_app() {
  info "Writing Node-Agent app..."
  mkdir -p "${NODE_DIR}/app"

  cat > "${NODE_DIR}/requirements.txt" << 'REQ'
fastapi==0.115.6
uvicorn[standard]==0.30.6
pydantic==2.10.3
REQ

  cat > "${NODE_DIR}/app/main.py" << 'PY'
import os, json, sqlite3, subprocess
from datetime import datetime
from typing import Optional, Dict, Any, List

from fastapi import FastAPI, HTTPException, Depends, Request
from pydantic import BaseModel, Field

APP_NAME="lxd-node-agent-v2"
DB_PATH=os.getenv("NODE_DB","/var/lib/lxd-panel-v2/node.db")
NODE_ID=os.getenv("NODE_ID","")
NODE_SECRET=os.getenv("NODE_SECRET","")
LXD_SOCKET=os.getenv("NODE_LXD_SOCKET","/var/lib/lxd/unix.socket")

PORT_MIN=int(os.getenv("NODE_PORT_MIN","20000"))
PORT_MAX=int(os.getenv("NODE_PORT_MAX","40000"))
DEFAULT_PROFILE=os.getenv("NODE_DEFAULT_PROFILE","default")

app=FastAPI(title="LXD Node-Agent v2", version="2.0.0")

def db():
    c=sqlite3.connect(DB_PATH)
    c.row_factory=sqlite3.Row
    return c

def init_db():
    c=db()
    c.execute("""CREATE TABLE IF NOT EXISTS ports(
      host_port INTEGER PRIMARY KEY,
      in_use INTEGER NOT NULL DEFAULT 0,
      container TEXT,
      container_port INTEGER,
      proto TEXT,
      created_at TEXT
    )""")
    c.execute("""CREATE TABLE IF NOT EXISTS audit(
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      ts TEXT NOT NULL,
      action TEXT NOT NULL,
      detail TEXT NOT NULL
    )""")
    c.commit(); c.close()

@app.on_event("startup")
def _startup():
    init_db()

def audit(action:str, detail:Dict[str,Any]):
    c=db()
    c.execute("INSERT INTO audit(ts,action,detail) VALUES(?,?,?)",
              (datetime.utcnow().isoformat()+"Z", action, json.dumps(detail, ensure_ascii=False)))
    c.commit(); c.close()

def require_panel(request:Request):
    got=request.headers.get("X-Node-Secret","")
    if not NODE_SECRET or got!=NODE_SECRET:
        raise HTTPException(401,"Bad node secret")
    return True

def run_lxc(args:List[str], timeout:int=120)->str:
    cmd=["lxc"]+args
    p=subprocess.run(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True, timeout=timeout)
    if p.returncode!=0:
        raise HTTPException(400, f"lxc error: {p.stderr.strip()}")
    return p.stdout.strip()

def lxc_json(args:List[str])->Any:
    out=run_lxc(args+["--format=json"])
    try:
        return json.loads(out) if out else None
    except Exception:
        raise HTTPException(500,"Failed to parse JSON")

def ensure_port_rows():
    c=db()
    n=c.execute("SELECT COUNT(*) AS c FROM ports").fetchone()["c"]
    if n==0:
        now=datetime.utcnow().isoformat()+"Z"
        c.executemany("INSERT INTO ports(host_port,in_use,created_at) VALUES(?,?,?)",
                      [(p,0,now) for p in range(PORT_MIN, PORT_MAX+1)])
        c.commit()
    c.close()

def allocate_port(container:str, cport:int, proto:str)->int:
    ensure_port_rows()
    c=db()
    row=c.execute("SELECT host_port FROM ports WHERE in_use=0 LIMIT 1").fetchone()
    if not row:
        c.close()
        raise HTTPException(409,"Port pool exhausted")
    hp=int(row["host_port"])
    c.execute("UPDATE ports SET in_use=1, container=?, container_port=?, proto=?, created_at=? WHERE host_port=?",
              (container, int(cport), proto, datetime.utcnow().isoformat()+"Z", hp))
    c.commit(); c.close()
    return hp

def release_port(host_port:int):
    c=db()
    c.execute("UPDATE ports SET in_use=0, container=NULL, container_port=NULL, proto=NULL WHERE host_port=?",
              (int(host_port),))
    c.commit(); c.close()

def get_inst_ipv4(name:str)->str:
    st=lxc_json(["query", f"/1.0/instances/{name}/state"])
    ip=None
    if st and "network" in st:
        for _, meta in st["network"].items():
            for a in meta.get("addresses", []):
                if a.get("family")=="inet" and a.get("scope")=="global":
                    ip=a.get("address"); break
            if ip: break
    if not ip:
        raise HTTPException(409,"Instance has no IPv4 yet (start it and wait DHCP)")
    return ip

def get_host_veth(name:str)->Optional[str]:
    st=lxc_json(["query", f"/1.0/instances/{name}/state"])
    if not st: return None
    net=st.get("network",{})
    for _, meta in net.items():
        hn=meta.get("host_name")
        if hn: return hn
    return None

def tc_limit(dev:str, up_mbit:Optional[int], down_mbit:Optional[int]):
    if not dev:
        raise HTTPException(400,"No host veth found")
    def sh(cmd:List[str]):
        subprocess.run(cmd, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
    # egress
    sh(["tc","qdisc","del","dev",dev,"root"])
    if up_mbit and up_mbit>0:
        sh(["tc","qdisc","add","dev",dev,"root","handle","1:","htb","default","10"])
        sh(["tc","class","add","dev",dev,"parent","1:","classid","1:10","htb","rate",f"{up_mbit}mbit","ceil",f"{up_mbit}mbit"])
    # ingress via ifb
    ifb=f"ifb-{dev}"[:15]
    sh(["modprobe","ifb"])
    sh(["ip","link","add",ifb,"type","ifb"])
    sh(["ip","link","set","dev",ifb,"up"])
    sh(["tc","qdisc","del","dev",dev,"ingress"])
    sh(["tc","qdisc","del","dev",ifb,"root"])
    if down_mbit and down_mbit>0:
        sh(["tc","qdisc","add","dev",dev,"handle","ffff:","ingress"])
        sh(["tc","filter","add","dev",dev,"parent","ffff:","protocol","ip","u32","match","u32","0","0","action","mirred","egress","redirect","dev",ifb])
        sh(["tc","qdisc","add","dev",ifb,"root","handle","2:","htb","default","20"])
        sh(["tc","class","add","dev",ifb,"parent","2:","classid","2:20","htb","rate",f"{down_mbit}mbit","ceil",f"{down_mbit}mbit"])

# ---------------- Models ----------------
class CreateInstanceReq(BaseModel):
    name: str = Field(..., pattern=r"^[a-zA-Z0-9][a-zA-Z0-9\-]{1,61}$")
    image: str = "images:ubuntu/22.04"
    profiles: List[str] = Field(default_factory=lambda:[DEFAULT_PROFILE])
    cpu_cores: Optional[int] = Field(None, ge=1, le=256)
    cpu_limit_percent: Optional[int] = Field(None, ge=1, le=100)
    memory_mb: Optional[int] = Field(None, ge=128)
    disk_gb: Optional[int] = Field(None, ge=1)
    up_mbit: Optional[int] = Field(None, ge=1)
    down_mbit: Optional[int] = Field(None, ge=1)

class LimitReq(BaseModel):
    cpu_cores: Optional[int] = Field(None, ge=1, le=256)
    cpu_limit_percent: Optional[int] = Field(None, ge=1, le=100)
    memory_mb: Optional[int] = Field(None, ge=128)
    disk_gb: Optional[int] = Field(None, ge=1)
    up_mbit: Optional[int] = Field(None, ge=1)
    down_mbit: Optional[int] = Field(None, ge=1)

class PortMapReq(BaseModel):
    container_port:int = Field(..., ge=1, le=65535)
    proto:str = Field("tcp", pattern=r"^(tcp|udp)$")
    host_port: Optional[int] = Field(None, ge=1, le=65535)

class ReinstallReq(BaseModel):
    image:str
    preserve_ports: bool=True
    preserve_limits: bool=True

class LinuxUserReq(BaseModel):
    username: str = Field(..., pattern=r"^[a-z_][a-z0-9_-]{0,30}$")
    password: Optional[str] = None
    ssh_public_key: Optional[str] = None
    sudo: bool = True

@app.get("/node/health")
def node_health(_=Depends(require_panel)):
    return {"ok":True,"name":APP_NAME,"node_id":NODE_ID,"ts":datetime.utcnow().isoformat()+"Z"}

@app.get("/audit")
def get_audit(limit:int=200, _=Depends(require_panel)):
    c=db()
    rows=c.execute("SELECT * FROM audit ORDER BY id DESC LIMIT ?", (int(limit),)).fetchall()
    c.close()
    return {"audit":[dict(r) for r in rows]}

@app.get("/instances")
def list_instances(_=Depends(require_panel)):
    return {"instances": lxc_json(["list"])}

@app.get("/instances/{name}")
def get_instance(name:str, _=Depends(require_panel)):
    return {"instance": lxc_json(["query", f"/1.0/instances/{name}"])}

@app.post("/instances")
def create_instance(req:CreateInstanceReq, _=Depends(require_panel)):
    args=["launch", req.image, req.name]
    for p in req.profiles: args += ["-p", p]
    run_lxc(args, timeout=600)

    # limits
    if req.cpu_cores: run_lxc(["config","set",req.name,"limits.cpu",str(req.cpu_cores)])
    if req.cpu_limit_percent: run_lxc(["config","set",req.name,"limits.cpu.allowance",f"{req.cpu_limit_percent}%"])
    if req.memory_mb: run_lxc(["config","set",req.name,"limits.memory",f"{req.memory_mb}MB"])
    if req.disk_gb:
        try: run_lxc(["config","device","set",req.name,"root","size",f"{req.disk_gb}GB"])
        except HTTPException: pass

    if req.up_mbit or req.down_mbit:
        dev=get_host_veth(req.name)
        tc_limit(dev, req.up_mbit, req.down_mbit)

    audit("instance.create", req.model_dump())
    return {"ok":True,"name":req.name}

@app.post("/instances/{name}/start")
def start(name:str, _=Depends(require_panel)):
    run_lxc(["start",name], timeout=120)
    audit("instance.start", {"name":name})
    return {"ok":True}

@app.post("/instances/{name}/stop")
def stop(name:str, _=Depends(require_panel)):
    run_lxc(["stop",name,"--force"], timeout=120)
    audit("instance.stop", {"name":name})
    return {"ok":True}

@app.delete("/instances/{name}")
def delete(name:str, _=Depends(require_panel)):
    # release ports
    c=db()
    rows=c.execute("SELECT host_port FROM ports WHERE in_use=1 AND container=?", (name,)).fetchall()
    c.close()
    for r in rows: release_port(int(r["host_port"]))
    run_lxc(["delete",name,"--force"], timeout=300)
    audit("instance.delete", {"name":name})
    return {"ok":True}

@app.post("/instances/{name}/limits")
def set_limits(name:str, req:LimitReq, _=Depends(require_panel)):
    if req.cpu_cores: run_lxc(["config","set",name,"limits.cpu",str(req.cpu_cores)])
    if req.cpu_limit_percent: run_lxc(["config","set",name,"limits.cpu.allowance",f"{req.cpu_limit_percent}%"])
    if req.memory_mb: run_lxc(["config","set",name,"limits.memory",f"{req.memory_mb}MB"])
    if req.disk_gb:
        try: run_lxc(["config","device","set",name,"root","size",f"{req.disk_gb}GB"])
        except HTTPException: pass
    if req.up_mbit or req.down_mbit:
        dev=get_host_veth(name)
        tc_limit(dev, req.up_mbit, req.down_mbit)
    audit("limits.set", {"name":name, **req.model_dump()})
    return {"ok":True}

@app.get("/ports")
def list_ports(_=Depends(require_panel)):
    ensure_port_rows()
    c=db()
    rows=c.execute("SELECT * FROM ports ORDER BY host_port").fetchall()
    c.close()
    return {"ports":[dict(r) for r in rows]}

@app.post("/instances/{name}/ports")
def add_port(name:str, req:PortMapReq, _=Depends(require_panel)):
    host_port = int(req.host_port) if req.host_port else allocate_port(name, req.container_port, req.proto)
    ip = get_inst_ipv4(name)
    dev_name=f"p{host_port}-{req.proto}"
    listen=f"{req.proto}:0.0.0.0:{host_port}"
    connect=f"{req.proto}:{ip}:{req.container_port}"

    # idempotent: remove then add
    try: run_lxc(["config","device","remove",name,dev_name])
    except HTTPException: pass
    run_lxc(["config","device","add",name,dev_name,"proxy",f"listen={listen}",f"connect={connect}"])
    audit("port.add", {"name":name,"host_port":host_port,"container_port":req.container_port,"proto":req.proto})
    return {"ok":True,"host_port":host_port,"container_ip":ip,"device":dev_name}

@app.delete("/instances/{name}/ports/{host_port}")
def del_port(name:str, host_port:int, _=Depends(require_panel)):
    for proto in ("tcp","udp"):
        dev_name=f"p{int(host_port)}-{proto}"
        try: run_lxc(["config","device","remove",name,dev_name])
        except HTTPException: pass
    release_port(int(host_port))
    audit("port.del", {"name":name,"host_port":int(host_port)})
    return {"ok":True}

@app.post("/instances/{name}/reinstall")
def reinstall(name:str, req:ReinstallReq, _=Depends(require_panel)):
    inst=lxc_json(["query", f"/1.0/instances/{name}"])
    config=inst.get("config",{})
    devices=inst.get("devices",{})
    profiles=inst.get("profiles",[DEFAULT_PROFILE])

    c=db()
    ports=c.execute("SELECT host_port,container_port,proto FROM ports WHERE in_use=1 AND container=?", (name,)).fetchall()
    c.close()

    try: run_lxc(["stop",name,"--force"], timeout=120)
    except HTTPException: pass
    run_lxc(["delete",name,"--force"], timeout=300)

    args=["launch", req.image, name]
    for p in profiles: args += ["-p", p]
    run_lxc(args, timeout=600)

    if req.preserve_limits:
        for k,v in config.items():
            if k.startswith("volatile."): continue
            try: run_lxc(["config","set",name,k,v])
            except HTTPException: pass

    # restore non-default devices (keep eth0/root managed by profiles)
    for dev_name, dev in devices.items():
        if dev_name in ("eth0","root"): continue
        dtype=dev.get("type")
        if not dtype: continue
        cmd=["config","device","add",name,dev_name,dtype]
        for k,v in dev.items():
            if k=="type": continue
            cmd.append(f"{k}={v}")
        try: run_lxc(cmd)
        except HTTPException: pass

    if req.preserve_ports and ports:
        ip=get_inst_ipv4(name)
        for r in ports:
            hp=int(r["host_port"]); cp=int(r["container_port"]); proto=str(r["proto"] or "tcp")
            dev_name=f"p{hp}-{proto}"
            listen=f"{proto}:0.0.0.0:{hp}"
            connect=f"{proto}:{ip}:{cp}"
            try: run_lxc(["config","device","remove",name,dev_name])
            except HTTPException: pass
            run_lxc(["config","device","add",name,dev_name,"proxy",f"listen={listen}",f"connect={connect}"])

    audit("instance.reinstall", {"name":name, **req.model_dump()})
    return {"ok":True}

# -------- Linux user management inside container --------
@app.post("/instances/{name}/users")
def create_linux_user(name:str, req:LinuxUserReq, _=Depends(require_panel)):
    # Ensure container is running for exec
    try:
        run_lxc(["start", name], timeout=120)
    except HTTPException:
        pass

    u=req.username
    cmds=[]
    cmds.append(f"id -u {u} >/dev/null 2>&1 || useradd -m -s /bin/bash {u}")
    if req.password:
        # chpasswd expects "user:pass"
        cmds.append(f"printf '{u}:{req.password}' | chpasswd")
    if req.sudo:
        cmds.append(f"usermod -aG sudo {u} || true")
        cmds.append(f"echo '{u} ALL=(ALL) NOPASSWD:ALL' >/etc/sudoers.d/{u} && chmod 440 /etc/sudoers.d/{u}")
    if req.ssh_public_key:
        cmds.append(f"mkdir -p /home/{u}/.ssh && chmod 700 /home/{u}/.ssh")
        cmds.append(f"grep -qxF '{req.ssh_public_key}' /home/{u}/.ssh/authorized_keys 2>/dev/null || echo '{req.ssh_public_key}' >> /home/{u}/.ssh/authorized_keys")
        cmds.append(f"chmod 600 /home/{u}/.ssh/authorized_keys")
        cmds.append(f"chown -R {u}:{u} /home/{u}/.ssh")

    # Run in one shell
    script=" && ".join(cmds)
    run_lxc(["exec", name, "--", "bash", "-lc", script], timeout=180)
    audit("linux_user.create", {"name":name, **req.model_dump(exclude={"password"})})
    return {"ok":True, "username":u}
PY

  ok "Node-Agent app written."
}

node_venv() {
  info "Setting up Node-Agent venv..."
  python3 -m venv "${NODE_DIR}/venv"
  "${NODE_DIR}/venv/bin/pip" install --upgrade pip >/dev/null
  "${NODE_DIR}/venv/bin/pip" install -r "${NODE_DIR}/requirements.txt" >/dev/null
  ok "Node deps installed."
}

write_node_env_from_enroll() {
  [[ -n "$PANEL_URL" ]] || die "MODE=node requires PANEL_URL"
  [[ -n "$PAIR_TOKEN" ]] || die "MODE=node requires PAIR_TOKEN"

  local node_name node_url lxd_sock
  node_name="$(hostname -s 2>/dev/null || echo node)"
  lxd_sock="$(detect_lxd_socket)"

  # Determine node URL
  local ip
  ip="$(hostname -I 2>/dev/null | awk '{print $1}')"
  [[ -z "$ip" ]] && ip="127.0.0.1"
  node_url="http://${ip}:${NODE_PORT}"

  info "Enrolling node into panel..."
  # enroll request
  local resp node_id node_secret
  resp="$(curl -sS "${PANEL_URL%/}/nodes/enroll" \
    -H 'Content-Type: application/json' \
    -d "{\"token\":\"${PAIR_TOKEN}\",\"name\":\"${node_name}\",\"url\":\"${node_url}\"}")" || true

  node_id="$(echo "$resp" | jq -r '.node_id // empty')"
  node_secret="$(echo "$resp" | jq -r '.node_secret // empty')"

  [[ -n "$node_id" && -n "$node_secret" ]] || die "Enroll failed: $resp"

  cat > "${CFG_DIR}/node.env" << EOF
NODE_DB=${DATA_DIR}/node.db
NODE_ID=${node_id}
NODE_SECRET=${node_secret}
NODE_LXD_SOCKET=${lxd_sock}

NODE_PORT_MIN=${PORT_MIN}
NODE_PORT_MAX=${PORT_MAX}
NODE_DEFAULT_PROFILE=${DEFAULT_PROFILE}
EOF
  chmod 600 "${CFG_DIR}/node.env"
  ok "Node env written: ${CFG_DIR}/node.env"
  echo "$node_id" > "${CFG_DIR}/node.id"; chmod 600 "${CFG_DIR}/node.id"
}

write_node_systemd() {
  info "Writing Node-Agent systemd..."
  cat > /etc/systemd/system/lxd-node-agent.service << EOF
[Unit]
Description=LXD Node-Agent v2 (LXD host)
After=network.target lxd.service
Wants=lxd.service

[Service]
Type=simple
EnvironmentFile=${CFG_DIR}/node.env
WorkingDirectory=${NODE_DIR}
ExecStart=${NODE_DIR}/venv/bin/uvicorn app.main:app --host ${BIND_ADDR} --port ${NODE_PORT} --proxy-headers
Restart=always
RestartSec=2
User=root
NoNewPrivileges=true
PrivateTmp=true
ProtectHome=true
ProtectSystem=full
ReadWritePaths=${DATA_DIR} ${LOG_DIR} ${CFG_DIR} ${NODE_DIR}

[Install]
WantedBy=multi-user.target
EOF
  systemctl daemon-reload
  systemctl enable lxd-node-agent >/dev/null
  systemctl restart lxd-node-agent
  ok "Node-Agent service started: lxd-node-agent"
}

# ------------------------------------------------------------------------------
# MAIN
# ------------------------------------------------------------------------------
panel_print() {
  local ip admin_pass
  ip="$(hostname -I 2>/dev/null | awk '{print $1}')"; [[ -z "$ip" ]] && ip="127.0.0.1"
  admin_pass="$(cat "${CFG_DIR}/panel.admin.pass")"

  echo -e "\n${GREEN}================= PANEL READY =================${PLAIN}"
  echo -e "Panel API Base: ${BLUE}http://${ip}:${API_PORT}${PLAIN}"
  echo -e "Admin pass:     ${YELLOW}${admin_pass}${PLAIN}  (saved: ${CFG_DIR}/panel.admin.pass)"
  echo -e "\nCreate a pair token (for node enroll):"
  cat << EOF
  TOKEN=\$(curl -s http://${ip}:${API_PORT}/auth/login \\
    -H 'Content-Type: application/json' \\
    -d '{"username":"admin","password":"${admin_pass}"}' | jq -r .token)

  PAIR=\$(curl -s http://${ip}:${API_PORT}/nodes/pair_token \\
    -H "Authorization: Bearer \$TOKEN" | jq -r .token)

  echo "PAIR_TOKEN=\$PAIR"
EOF
  echo -e "\nAfter a node enrolls, use the panel proxy endpoints like:"
  cat << EOF
  # list nodes
  curl -s http://${ip}:${API_PORT}/nodes -H "Authorization: Bearer \$TOKEN" | jq

  # health check a node
  NODE_ID="(from /nodes output)"
  curl -s http://${ip}:${API_PORT}/nodes/\$NODE_ID/health -H "Authorization: Bearer \$TOKEN" | jq

  # create instance on node via proxy
  curl -s http://${ip}:${API_PORT}/nodes/\$NODE_ID/instances \\
    -H "Authorization: Bearer \$TOKEN" -H 'Content-Type: application/json' \\
    -d '{"name":"ct-001","image":"images:ubuntu/22.04","cpu_cores":2,"memory_mb":2048,"up_mbit":50,"down_mbit":200}' | jq
EOF
  echo -e "${GREEN}==============================================${PLAIN}\n"
}

node_print() {
  local ip node_id
  ip="$(hostname -I 2>/dev/null | awk '{print $1}')"; [[ -z "$ip" ]] && ip="127.0.0.1"
  node_id="$(cat "${CFG_DIR}/node.id" 2>/dev/null || echo "unknown")"
  echo -e "\n${GREEN}================= NODE READY =================${PLAIN}"
  echo -e "Node-Agent URL: ${BLUE}http://${ip}:${NODE_PORT}${PLAIN}"
  echo -e "Node ID:        ${YELLOW}${node_id}${PLAIN}"
  echo -e "Note: Node-Agent is not meant for direct access; call through the Panel."
  echo -e "${GREEN}==============================================${PLAIN}\n"
}

common_steps() {
  install_pkgs_common
  mk_dirs
}

panel_steps() {
  write_panel_app
  panel_venv
  write_panel_env
  bootstrap_panel_db
  write_panel_systemd
  systemctl is-active --quiet lxd-panel || die "Panel service failed"
  panel_print
}

node_steps() {
  install_lxd_if_needed
  init_lxd_if_needed
  write_node_app
  node_venv
  write_node_env_from_enroll
  write_node_systemd
  systemctl is-active --quiet lxd-node-agent || die "Node-Agent service failed"
  node_print
}

info "MODE=${MODE}"
case "$MODE" in
  panel)
    common_steps
    panel_steps
    ;;
  node)
    common_steps
    node_steps
    ;;
  *)
    die "Unknown MODE: ${MODE} (use panel|node)"
    ;;
esac
