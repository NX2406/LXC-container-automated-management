#!/bin/bash
set -euo pipefail

# ==============================================================================
# LXD Panel v2 - Menu One-click Script (Panel-first + Node enroll)
# ------------------------------------------------------------------------------
# Menu:
#   1) 安装 Panel 后端（中心端）
#   2) 显示 Panel 对接 API（含登录信息）
#   3) 生成节点配对 Token（pair_token）
#   4) 安装 Node-Agent（宿主机）并对接到 Panel（enroll）
#   5) 显示 Node 对接信息（Node-Agent 地址 + 当前节点ID）
#   6) 卸载 Panel（可选保留数据）
#   7) 卸载 Node-Agent（可选保留数据）
#   0) 退出
#
# 说明：
# - Panel 永远先可登录（不依赖节点）
# - Node 通过 pair_token enroll 注册到 Panel，替代粘贴大 bundle
# - Panel 代理转发调用节点：/nodes/{node_id}/...
#
# 运行：
#   chmod +x lxd-panel-menu-v2.sh && ./lxd-panel-menu-v2.sh
#
# 可选环境变量（默认值见下）：
#   PANEL_API_PORT=9876
#   PANEL_BIND_ADDR=0.0.0.0
#   NODE_PORT=19876
#   NODE_BIND_ADDR=0.0.0.0
#   PORT_MIN=20000 PORT_MAX=40000 DEFAULT_PROFILE=default
# ==============================================================================

RED='\033[0;31m'; GREEN='\033[0;32m'; YELLOW='\033[0;33m'; BLUE='\033[0;36m'; PLAIN='\033[0m'
info(){ echo -e "${BLUE}[INFO]${PLAIN} $*"; }
ok(){ echo -e "${GREEN}[OK]${PLAIN} $*"; }
warn(){ echo -e "${YELLOW}[WARN]${PLAIN} $*"; }
die(){ echo -e "${RED}[ERR]${PLAIN} $*"; exit 1; }

[[ $EUID -eq 0 ]] || die "请用 root 运行"

export DEBIAN_FRONTEND=noninteractive

# ---------------- Defaults ----------------
PANEL_API_PORT="${PANEL_API_PORT:-9876}"
PANEL_BIND_ADDR="${PANEL_BIND_ADDR:-0.0.0.0}"

NODE_PORT="${NODE_PORT:-19876}"
NODE_BIND_ADDR="${NODE_BIND_ADDR:-0.0.0.0}"

PORT_MIN="${PORT_MIN:-20000}"
PORT_MAX="${PORT_MAX:-40000}"
DEFAULT_PROFILE="${DEFAULT_PROFILE:-default}"

BASE="/opt/lxd-panel-v2"
PANEL_DIR="${BASE}/panel"
NODE_DIR="${BASE}/node"

CFG_DIR="/etc/lxd-panel-v2"
DATA_DIR="/var/lib/lxd-panel-v2"
LOG_DIR="/var/log/lxd-panel-v2"

PANEL_SERVICE="lxd-panel"
NODE_SERVICE="lxd-node-agent"

# ---------------- Helpers ----------------
need_cmd(){ command -v "$1" >/dev/null 2>&1; }

rand_pw(){ tr -dc 'A-Za-z0-9_@#%+=' </dev/urandom | head -c 20; }
rand_hex(){ tr -dc 'a-f0-9' </dev/urandom | head -c "${1:-48}"; }

host_ip() {
  local ip
  ip="$(hostname -I 2>/dev/null | awk '{print $1}')"
  [[ -z "${ip}" ]] && ip="127.0.0.1"
  echo "$ip"
}

detect_lxd_socket() {
  local s1="/var/lib/lxd/unix.socket"
  local s2="/var/snap/lxd/common/lxd/unix.socket"
  [[ -S "$s1" ]] && { echo "$s1"; return; }
  [[ -S "$s2" ]] && { echo "$s2"; return; }
  echo "$s1"
}

install_pkgs_common() {
  info "安装基础依赖..."
  apt-get update -y
  apt-get install -y curl ca-certificates jq sqlite3 iproute2 iptables \
    python3 python3-venv python3-pip uidmap
  ok "基础依赖安装完成"
}

install_lxd_if_needed() {
  if ! need_cmd lxc; then
    info "安装 LXD（apt）..."
    apt-get install -y lxd
  else
    ok "LXD 已存在"
  fi
}

init_lxd_if_needed() {
  info "检查 LXD 是否初始化..."
  if ! lxc info >/dev/null 2>&1; then
    warn "LXD 未初始化，执行 lxd init --auto（安全默认）..."
    lxd init --auto >/dev/null
  fi
  ok "LXD Ready（socket=$(detect_lxd_socket)）"
}

ensure_dirs() {
  mkdir -p "$BASE" "$CFG_DIR" "$DATA_DIR" "$LOG_DIR"
  chmod 750 "$DATA_DIR" "$LOG_DIR" || true
}

# ==============================================================================
# PANEL (Central)
# ==============================================================================
write_panel_app() {
  info "写入 Panel 后端代码..."
  mkdir -p "${PANEL_DIR}/app"

  cat > "${PANEL_DIR}/requirements.txt" << 'REQ'
fastapi==0.115.6
uvicorn[standard]==0.30.6
pyjwt==2.9.0
passlib[bcrypt]==1.7.4
pydantic==2.10.3
httpx==0.27.2
REQ

  cat > "${PANEL_DIR}/app/main.py" << 'PY'
import os, json, sqlite3, secrets, time
from datetime import datetime, timedelta
from typing import Optional, Dict, Any

import jwt
import httpx
from fastapi import FastAPI, HTTPException, Depends, Request
from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials
from pydantic import BaseModel, Field
from passlib.context import CryptContext

APP_NAME="lxd-panel-v2"
DB_PATH=os.getenv("PANEL_DB","/var/lib/lxd-panel-v2/panel.db")
JWT_SECRET=os.getenv("PANEL_JWT_SECRET","change-me")
JWT_ISSUER=os.getenv("PANEL_JWT_ISSUER","lxd-panel-v2")
JWT_EXPIRE_MIN=int(os.getenv("PANEL_JWT_EXPIRE_MIN","1440"))
ADMIN_USER=os.getenv("PANEL_ADMIN_USER","admin")
ADMIN_PASS=os.getenv("PANEL_ADMIN_PASS","")

pwd=CryptContext(schemes=["bcrypt"], deprecated="auto")
bearer=HTTPBearer(auto_error=False)
app=FastAPI(title="LXD Panel v2", version="2.0.0")

def db():
    c=sqlite3.connect(DB_PATH)
    c.row_factory=sqlite3.Row
    return c

def init_db():
    c=db(); cur=c.cursor()
    cur.execute("""CREATE TABLE IF NOT EXISTS users(
      username TEXT PRIMARY KEY,
      password_hash TEXT NOT NULL,
      role TEXT NOT NULL,
      created_at TEXT NOT NULL
    )""")
    cur.execute("""CREATE TABLE IF NOT EXISTS nodes(
      id TEXT PRIMARY KEY,
      name TEXT NOT NULL,
      url TEXT NOT NULL,
      secret TEXT NOT NULL,
      created_at TEXT NOT NULL,
      last_seen TEXT
    )""")
    cur.execute("""CREATE TABLE IF NOT EXISTS pair_tokens(
      token TEXT PRIMARY KEY,
      expires_at INTEGER NOT NULL,
      used INTEGER NOT NULL DEFAULT 0,
      created_at TEXT NOT NULL
    )""")
    cur.execute("""CREATE TABLE IF NOT EXISTS audit(
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      ts TEXT NOT NULL,
      actor TEXT NOT NULL,
      action TEXT NOT NULL,
      detail TEXT NOT NULL
    )""")
    c.commit(); c.close()

def audit(actor:str, action:str, detail:Dict[str,Any]):
    c=db()
    c.execute("INSERT INTO audit(ts,actor,action,detail) VALUES(?,?,?,?)",
              (datetime.utcnow().isoformat()+"Z", actor, action, json.dumps(detail, ensure_ascii=False)))
    c.commit(); c.close()

def ensure_admin():
    if not ADMIN_PASS:
        return
    c=db()
    r=c.execute("SELECT username FROM users WHERE username=?", (ADMIN_USER,)).fetchone()
    if not r:
        c.execute("INSERT INTO users(username,password_hash,role,created_at) VALUES(?,?,?,?)",
                  (ADMIN_USER, pwd.hash(ADMIN_PASS), "admin", datetime.utcnow().isoformat()+"Z"))
        c.commit()
    c.close()

@app.on_event("startup")
def _startup():
    init_db()
    ensure_admin()

def mk_token(username:str, role:str)->str:
    now=datetime.utcnow()
    payload={"iss":JWT_ISSUER,"sub":username,"role":role,"iat":int(now.timestamp()),
             "exp":int((now+timedelta(minutes=JWT_EXPIRE_MIN)).timestamp())}
    return jwt.encode(payload, JWT_SECRET, algorithm="HS256")

def verify(creds: Optional[HTTPAuthorizationCredentials]) -> Dict[str,Any]:
    if not creds:
        raise HTTPException(401,"Missing Authorization")
    try:
        return jwt.decode(creds.credentials, JWT_SECRET, algorithms=["HS256"])
    except Exception:
        raise HTTPException(401,"Invalid token")

def require_admin(payload=Depends(lambda c=Depends(bearer): verify(c))):
    if payload.get("role")!="admin":
        raise HTTPException(403,"Admin only")
    return payload

class LoginReq(BaseModel):
    username:str
    password:str

@app.get("/health")
def health():
    return {"ok":True,"name":APP_NAME,"ts":datetime.utcnow().isoformat()+"Z"}

@app.post("/auth/login")
def login(req:LoginReq):
    c=db()
    r=c.execute("SELECT username,password_hash,role FROM users WHERE username=?", (req.username,)).fetchone()
    c.close()
    if not r or not pwd.verify(req.password, r["password_hash"]):
        raise HTTPException(401,"Bad credentials")
    t=mk_token(r["username"], r["role"])
    audit(r["username"],"login",{"username":r["username"]})
    return {"token":t,"role":r["role"]}

# -------- Pair Token --------
class PairTokenResp(BaseModel):
    token:str
    expires_in:int

@app.post("/nodes/pair_token", response_model=PairTokenResp, dependencies=[Depends(require_admin)])
def create_pair_token(ttl_seconds:int=600, payload=Depends(require_admin)):
    ttl_seconds=max(60, min(ttl_seconds, 3600))
    token=secrets.token_urlsafe(24)
    exp=int(time.time())+ttl_seconds
    c=db()
    c.execute("INSERT INTO pair_tokens(token,expires_at,used,created_at) VALUES(?,?,0,?)",
              (token, exp, datetime.utcnow().isoformat()+"Z"))
    c.commit(); c.close()
    audit(payload["sub"],"pair_token.create",{"ttl":ttl_seconds})
    return PairTokenResp(token=token, expires_in=ttl_seconds)

# -------- Enroll --------
class EnrollReq(BaseModel):
    token:str
    name:str = Field(..., min_length=1, max_length=64)
    url:str  = Field(..., min_length=5, max_length=256)

class EnrollResp(BaseModel):
    node_id:str
    node_secret:str

@app.post("/nodes/enroll", response_model=EnrollResp)
def enroll(req:EnrollReq, request:Request):
    now=int(time.time())
    c=db()
    t=c.execute("SELECT token,expires_at,used FROM pair_tokens WHERE token=?", (req.token,)).fetchone()
    if not t:
        c.close(); raise HTTPException(403,"Invalid pair token")
    if int(t["used"])==1:
        c.close(); raise HTTPException(403,"Pair token already used")
    if now>int(t["expires_at"]):
        c.close(); raise HTTPException(403,"Pair token expired")

    node_id=secrets.token_hex(8)
    node_secret=secrets.token_urlsafe(32)

    c.execute("UPDATE pair_tokens SET used=1 WHERE token=?", (req.token,))
    c.execute("INSERT INTO nodes(id,name,url,secret,created_at,last_seen) VALUES(?,?,?,?,?,?)",
              (node_id, req.name, req.url.rstrip("/"), node_secret, datetime.utcnow().isoformat()+"Z", None))
    c.commit(); c.close()

    audit("node-enroll","node.enroll",{"node_id":node_id,"name":req.name,"url":req.url,"from":request.client.host if request.client else None})
    return EnrollResp(node_id=node_id, node_secret=node_secret)

# -------- Nodes --------
@app.get("/nodes", dependencies=[Depends(require_admin)])
def list_nodes(payload=Depends(require_admin)):
    c=db()
    rows=c.execute("SELECT id,name,url,created_at,last_seen FROM nodes ORDER BY created_at DESC").fetchall()
    c.close()
    return {"nodes":[dict(r) for r in rows]}

@app.get("/nodes/{node_id}/health", dependencies=[Depends(require_admin)])
async def node_health(node_id:str, payload=Depends(require_admin)):
    c=db()
    n=c.execute("SELECT url,secret FROM nodes WHERE id=?", (node_id,)).fetchone()
    c.close()
    if not n: raise HTTPException(404,"Node not found")
    async with httpx.AsyncClient(timeout=6) as client:
        r=await client.get(f"{n['url']}/node/health", headers={"X-Node-Secret":n["secret"]})
    if r.status_code!=200:
        raise HTTPException(502,f"Node unhealthy: {r.text}")
    c=db()
    c.execute("UPDATE nodes SET last_seen=? WHERE id=?", (datetime.utcnow().isoformat()+"Z", node_id))
    c.commit(); c.close()
    return r.json()

# -------- Proxy to node --------
@app.api_route("/nodes/{node_id}/{path:path}", methods=["GET","POST","PUT","PATCH","DELETE"], dependencies=[Depends(require_admin)])
async def proxy(node_id:str, path:str, request:Request, payload=Depends(require_admin)):
    c=db()
    n=c.execute("SELECT url,secret FROM nodes WHERE id=?", (node_id,)).fetchone()
    c.close()
    if not n:
        raise HTTPException(404,"Node not found")

    target=f"{n['url'].rstrip('/')}/{path.lstrip('/')}"
    method=request.method.upper()
    params=dict(request.query_params)
    body=await request.body()

    headers={}
    if request.headers.get("content-type"):
        headers["content-type"]=request.headers["content-type"]
    headers["X-Node-Secret"]=n["secret"]

    async with httpx.AsyncClient(timeout=60) as client:
        r=await client.request(method, target, params=params, content=body, headers=headers)

    audit(payload["sub"],"node.proxy",{"node_id":node_id,"method":method,"path":path,"status":r.status_code})
    try:
        return r.json()
    except Exception:
        return {"status":r.status_code,"text":r.text}

@app.get("/audit", dependencies=[Depends(require_admin)])
def get_audit(limit:int=200, payload=Depends(require_admin)):
    c=db()
    rows=c.execute("SELECT * FROM audit ORDER BY id DESC LIMIT ?", (int(limit),)).fetchall()
    c.close()
    return {"audit":[dict(r) for r in rows]}
PY
  ok "Panel 代码写入完成"
}

panel_setup_venv() {
  info "安装 Panel Python 依赖..."
  python3 -m venv "${PANEL_DIR}/venv"
  "${PANEL_DIR}/venv/bin/pip" install --upgrade pip >/dev/null
  "${PANEL_DIR}/venv/bin/pip" install -r "${PANEL_DIR}/requirements.txt" >/dev/null
  ok "Panel 依赖安装完成"
}

panel_write_env() {
  info "写入 Panel 配置..."
  mkdir -p "$CFG_DIR" "$DATA_DIR" "$LOG_DIR"
  chmod 750 "$DATA_DIR" "$LOG_DIR" || true

  local admin_pass jwt_secret
  admin_pass="$(rand_pw)"
  jwt_secret="$(rand_hex 48)"

  cat > "${CFG_DIR}/panel.env" << EOF
PANEL_DB=${DATA_DIR}/panel.db
PANEL_ADMIN_USER=admin
PANEL_ADMIN_PASS=${admin_pass}
PANEL_JWT_SECRET=${jwt_secret}
PANEL_JWT_ISSUER=lxd-panel-v2
PANEL_JWT_EXPIRE_MIN=1440
EOF
  chmod 600 "${CFG_DIR}/panel.env"
  echo "$admin_pass" > "${CFG_DIR}/panel.admin.pass"
  chmod 600 "${CFG_DIR}/panel.admin.pass"
  ok "Panel 配置已生成：${CFG_DIR}/panel.env"
}

panel_bootstrap_db() {
  info "初始化 Panel DB..."
  set +u
  # shellcheck disable=SC1090
  source "${CFG_DIR}/panel.env"
  set -u

  python3 - << 'PY'
import os, sqlite3
from datetime import datetime
from passlib.context import CryptContext

DB=os.getenv("PANEL_DB")
ADMIN_USER=os.getenv("PANEL_ADMIN_USER","admin")
ADMIN_PASS=os.getenv("PANEL_ADMIN_PASS","")
pwd=CryptContext(schemes=["bcrypt"], deprecated="auto")

os.makedirs(os.path.dirname(DB), exist_ok=True)
c=sqlite3.connect(DB)
cur=c.cursor()
cur.execute("""CREATE TABLE IF NOT EXISTS users(
  username TEXT PRIMARY KEY,
  password_hash TEXT NOT NULL,
  role TEXT NOT NULL,
  created_at TEXT NOT NULL
)""")
cur.execute("""CREATE TABLE IF NOT EXISTS nodes(
  id TEXT PRIMARY KEY,
  name TEXT NOT NULL,
  url TEXT NOT NULL,
  secret TEXT NOT NULL,
  created_at TEXT NOT NULL,
  last_seen TEXT
)""")
cur.execute("""CREATE TABLE IF NOT EXISTS pair_tokens(
  token TEXT PRIMARY KEY,
  expires_at INTEGER NOT NULL,
  used INTEGER NOT NULL DEFAULT 0,
  created_at TEXT NOT NULL
)""")
cur.execute("""CREATE TABLE IF NOT EXISTS audit(
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  ts TEXT NOT NULL,
  actor TEXT NOT NULL,
  action TEXT NOT NULL,
  detail TEXT NOT NULL
)""")
c.commit()

if ADMIN_PASS:
    r=cur.execute("SELECT username FROM users WHERE username=?", (ADMIN_USER,)).fetchone()
    if not r:
        cur.execute("INSERT INTO users(username,password_hash,role,created_at) VALUES(?,?,?,?)",
                    (ADMIN_USER, pwd.hash(ADMIN_PASS), "admin", datetime.utcnow().isoformat()+"Z"))
        c.commit()
c.close()
PY
  ok "Panel DB 初始化完成：${DATA_DIR}/panel.db"
}

panel_systemd() {
  info "注册 Panel systemd..."
  cat > "/etc/systemd/system/${PANEL_SERVICE}.service" << EOF
[Unit]
Description=LXD Panel v2 (central)
After=network.target

[Service]
Type=simple
EnvironmentFile=${CFG_DIR}/panel.env
WorkingDirectory=${PANEL_DIR}
ExecStart=${PANEL_DIR}/venv/bin/uvicorn app.main:app --host ${PANEL_BIND_ADDR} --port ${PANEL_API_PORT} --proxy-headers
Restart=always
RestartSec=2
User=root
NoNewPrivileges=true
PrivateTmp=true
ProtectHome=true
ProtectSystem=full
ReadWritePaths=${DATA_DIR} ${LOG_DIR} ${CFG_DIR} ${PANEL_DIR}

[Install]
WantedBy=multi-user.target
EOF

  systemctl daemon-reload
  systemctl enable "${PANEL_SERVICE}" >/dev/null
  systemctl restart "${PANEL_SERVICE}"
  ok "Panel 服务已启动：${PANEL_SERVICE}"
}

panel_show_api() {
  local ip; ip="$(host_ip)"
  echo -e "\n${GREEN}================= Panel 对接信息 =================${PLAIN}"
  echo -e "API Base : ${BLUE}http://${ip}:${PANEL_API_PORT}${PLAIN}"
  echo -e "Health   : ${BLUE}GET  /health${PLAIN}"
  echo -e "Login    : ${BLUE}POST /auth/login${PLAIN}"
  echo -e "Nodes    : ${BLUE}GET  /nodes (需 JWT)${PLAIN}"
  echo -e "Proxy调用: ${BLUE}/nodes/{node_id}/...${PLAIN}"
  echo -e "Admin 密码文件: ${YELLOW}${CFG_DIR}/panel.admin.pass${PLAIN}"

  if [[ -f "${CFG_DIR}/panel.admin.pass" ]]; then
    local admin_pass; admin_pass="$(cat "${CFG_DIR}/panel.admin.pass")"
    echo -e "Admin: ${YELLOW}admin / ${admin_pass}${PLAIN}"
    echo -e "\n示例（获取 TOKEN）："
    cat << EOF
TOKEN=\$(curl -s http://${ip}:${PANEL_API_PORT}/auth/login \\
  -H 'Content-Type: application/json' \\
  -d '{"username":"admin","password":"${admin_pass}"}' | jq -r .token)
echo "\$TOKEN"
EOF
  else
    warn "未发现 admin 密码文件（可能未安装或被删除）"
  fi

  echo -e "\n监听检查："
  echo "  ss -lntp | grep -E '(:${PANEL_API_PORT}|uvicorn)' || true"
  echo -e "${GREEN}=================================================${PLAIN}\n"

  if curl -s "http://127.0.0.1:${PANEL_API_PORT}/health" >/dev/null 2>&1; then
    ok "本机可访问：curl http://127.0.0.1:${PANEL_API_PORT}/health"
  else
    warn "本机暂不可访问（看：systemctl status ${PANEL_SERVICE} --no-pager）"
  fi
}

panel_install() {
  install_pkgs_common
  ensure_dirs
  mkdir -p "${PANEL_DIR}"

  write_panel_app
  panel_setup_venv
  panel_write_env
  panel_bootstrap_db
  panel_systemd

  systemctl is-active --quiet "${PANEL_SERVICE}" && ok "Panel 安装成功" || warn "Panel 服务未正常运行"
  panel_show_api
}

panel_uninstall() {
  warn "卸载 Panel..."
  read -r -p "是否保留数据（DB/日志）？[y/N]: " keep
  keep="${keep:-N}"

  systemctl stop "${PANEL_SERVICE}" >/dev/null 2>&1 || true
  systemctl disable "${PANEL_SERVICE}" >/dev/null 2>&1 || true
  rm -f "/etc/systemd/system/${PANEL_SERVICE}.service"
  systemctl daemon-reload

  rm -rf "${PANEL_DIR}" || true
  rm -f "${CFG_DIR}/panel.env" "${CFG_DIR}/panel.admin.pass" || true

  if [[ "${keep}" =~ ^[Yy]$ ]]; then
    ok "已卸载 Panel（保留数据：${DATA_DIR} / ${LOG_DIR}）"
  else
    rm -rf "${DATA_DIR}" "${LOG_DIR}" || true
    ok "已卸载 Panel（数据也已清理）"
  fi
}

# ==============================================================================
# NODE (Host Agent)
# ==============================================================================
write_node_app() {
  info "写入 Node-Agent 代码..."
  mkdir -p "${NODE_DIR}/app"

  cat > "${NODE_DIR}/requirements.txt" << 'REQ'
fastapi==0.115.6
uvicorn[standard]==0.30.6
pydantic==2.10.3
REQ

  cat > "${NODE_DIR}/app/main.py" << 'PY'
import os, json, sqlite3, subprocess
from datetime import datetime
from typing import Optional, Dict, Any, List

from fastapi import FastAPI, HTTPException, Depends, Request
from pydantic import BaseModel, Field

APP_NAME="lxd-node-agent-v2"
DB_PATH=os.getenv("NODE_DB","/var/lib/lxd-panel-v2/node.db")
NODE_ID=os.getenv("NODE_ID","")
NODE_SECRET=os.getenv("NODE_SECRET","")
PORT_MIN=int(os.getenv("NODE_PORT_MIN","20000"))
PORT_MAX=int(os.getenv("NODE_PORT_MAX","40000"))
DEFAULT_PROFILE=os.getenv("NODE_DEFAULT_PROFILE","default")

app=FastAPI(title="LXD Node-Agent v2", version="2.0.0")

def db():
    c=sqlite3.connect(DB_PATH)
    c.row_factory=sqlite3.Row
    return c

def init_db():
    c=db()
    c.execute("""CREATE TABLE IF NOT EXISTS ports(
      host_port INTEGER PRIMARY KEY,
      in_use INTEGER NOT NULL DEFAULT 0,
      container TEXT,
      container_port INTEGER,
      proto TEXT,
      created_at TEXT
    )""")
    c.execute("""CREATE TABLE IF NOT EXISTS audit(
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      ts TEXT NOT NULL,
      action TEXT NOT NULL,
      detail TEXT NOT NULL
    )""")
    c.commit(); c.close()

@app.on_event("startup")
def _startup():
    init_db()

def audit(action:str, detail:Dict[str,Any]):
    c=db()
    c.execute("INSERT INTO audit(ts,action,detail) VALUES(?,?,?)",
              (datetime.utcnow().isoformat()+"Z", action, json.dumps(detail, ensure_ascii=False)))
    c.commit(); c.close()

def require_panel(request:Request):
    got=request.headers.get("X-Node-Secret","")
    if not NODE_SECRET or got!=NODE_SECRET:
        raise HTTPException(401,"Bad node secret")
    return True

def run_lxc(args:List[str], timeout:int=120)->str:
    cmd=["lxc"]+args
    p=subprocess.run(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True, timeout=timeout)
    if p.returncode!=0:
        raise HTTPException(400, f"lxc error: {p.stderr.strip()}")
    return p.stdout.strip()

def lxc_json(args:List[str])->Any:
    out=run_lxc(args+["--format=json"])
    try:
        return json.loads(out) if out else None
    except Exception:
        raise HTTPException(500,"Failed to parse JSON")

def ensure_port_rows():
    c=db()
    n=c.execute("SELECT COUNT(*) AS c FROM ports").fetchone()["c"]
    if n==0:
        now=datetime.utcnow().isoformat()+"Z"
        c.executemany("INSERT INTO ports(host_port,in_use,created_at) VALUES(?,?,?)",
                      [(p,0,now) for p in range(PORT_MIN, PORT_MAX+1)])
        c.commit()
    c.close()

def allocate_port(container:str, cport:int, proto:str)->int:
    ensure_port_rows()
    c=db()
    row=c.execute("SELECT host_port FROM ports WHERE in_use=0 LIMIT 1").fetchone()
    if not row:
        c.close()
        raise HTTPException(409,"Port pool exhausted")
    hp=int(row["host_port"])
    c.execute("UPDATE ports SET in_use=1, container=?, container_port=?, proto=?, created_at=? WHERE host_port=?",
              (container, int(cport), proto, datetime.utcnow().isoformat()+"Z", hp))
    c.commit(); c.close()
    return hp

def release_port(host_port:int):
    c=db()
    c.execute("UPDATE ports SET in_use=0, container=NULL, container_port=NULL, proto=NULL WHERE host_port=?",
              (int(host_port),))
    c.commit(); c.close()

def get_inst_ipv4(name:str)->str:
    st=lxc_json(["query", f"/1.0/instances/{name}/state"])
    ip=None
    if st and "network" in st:
        for _, meta in st["network"].items():
            for a in meta.get("addresses", []):
                if a.get("family")=="inet" and a.get("scope")=="global":
                    ip=a.get("address"); break
            if ip: break
    if not ip:
        raise HTTPException(409,"Instance has no IPv4 yet (start it and wait DHCP)")
    return ip

def get_host_veth(name:str)->Optional[str]:
    st=lxc_json(["query", f"/1.0/instances/{name}/state"])
    if not st: return None
    for _, meta in st.get("network", {}).items():
        hn=meta.get("host_name")
        if hn: return hn
    return None

def tc_limit(dev:str, up_mbit:Optional[int], down_mbit:Optional[int]):
    if not dev:
        raise HTTPException(400,"No host veth found")
    def sh(cmd:List[str]):
        subprocess.run(cmd, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
    sh(["tc","qdisc","del","dev",dev,"root"])
    if up_mbit and up_mbit>0:
        sh(["tc","qdisc","add","dev",dev,"root","handle","1:","htb","default","10"])
        sh(["tc","class","add","dev",dev,"parent","1:","classid","1:10","htb","rate",f"{up_mbit}mbit","ceil",f"{up_mbit}mbit"])
    ifb=f"ifb-{dev}"[:15]
    sh(["modprobe","ifb"])
    sh(["ip","link","add",ifb,"type","ifb"])
    sh(["ip","link","set","dev",ifb,"up"])
    sh(["tc","qdisc","del","dev",dev,"ingress"])
    sh(["tc","qdisc","del","dev",ifb,"root"])
    if down_mbit and down_mbit>0:
        sh(["tc","qdisc","add","dev",dev,"handle","ffff:","ingress"])
        sh(["tc","filter","add","dev",dev,"parent","ffff:","protocol","ip","u32","match","u32","0","0","action","mirred","egress","redirect","dev",ifb])
        sh(["tc","qdisc","add","dev",ifb,"root","handle","2:","htb","default","20"])
        sh(["tc","class","add","dev",ifb,"parent","2:","classid","2:20","htb","rate",f"{down_mbit}mbit","ceil",f"{down_mbit}mbit"])

class CreateInstanceReq(BaseModel):
    name: str = Field(..., pattern=r"^[a-zA-Z0-9][a-zA-Z0-9\-]{1,61}$")
    image: str = "images:ubuntu/22.04"
    profiles: List[str] = Field(default_factory=lambda:[DEFAULT_PROFILE])
    cpu_cores: Optional[int] = Field(None, ge=1, le=256)
    cpu_limit_percent: Optional[int] = Field(None, ge=1, le=100)
    memory_mb: Optional[int] = Field(None, ge=128)
    disk_gb: Optional[int] = Field(None, ge=1)
    up_mbit: Optional[int] = Field(None, ge=1)
    down_mbit: Optional[int] = Field(None, ge=1)

class LimitReq(BaseModel):
    cpu_cores: Optional[int] = Field(None, ge=1, le=256)
    cpu_limit_percent: Optional[int] = Field(None, ge=1, le=100)
    memory_mb: Optional[int] = Field(None, ge=128)
    disk_gb: Optional[int] = Field(None, ge=1)
    up_mbit: Optional[int] = Field(None, ge=1)
    down_mbit: Optional[int] = Field(None, ge=1)

class PortMapReq(BaseModel):
    container_port:int = Field(..., ge=1, le=65535)
    proto:str = Field("tcp", pattern=r"^(tcp|udp)$")
    host_port: Optional[int] = Field(None, ge=1, le=65535)

class ReinstallReq(BaseModel):
    image:str
    preserve_ports: bool=True
    preserve_limits: bool=True

class LinuxUserReq(BaseModel):
    username: str = Field(..., pattern=r"^[a-z_][a-z0-9_-]{0,30}$")
    password: Optional[str] = None
    ssh_public_key: Optional[str] = None
    sudo: bool = True

@app.get("/node/health")
def node_health(_=Depends(require_panel)):
    return {"ok":True,"name":APP_NAME,"node_id":NODE_ID,"ts":datetime.utcnow().isoformat()+"Z"}

@app.get("/instances")
def list_instances(_=Depends(require_panel)):
    return {"instances": lxc_json(["list"])}

@app.post("/instances")
def create_instance(req:CreateInstanceReq, _=Depends(require_panel)):
    args=["launch", req.image, req.name]
    for p in req.profiles: args += ["-p", p]
    run_lxc(args, timeout=600)

    if req.cpu_cores: run_lxc(["config","set",req.name,"limits.cpu",str(req.cpu_cores)])
    if req.cpu_limit_percent: run_lxc(["config","set",req.name,"limits.cpu.allowance",f"{req.cpu_limit_percent}%"])
    if req.memory_mb: run_lxc(["config","set",req.name,"limits.memory",f"{req.memory_mb}MB"])
    if req.disk_gb:
        try: run_lxc(["config","device","set",req.name,"root","size",f"{req.disk_gb}GB"])
        except HTTPException: pass

    if req.up_mbit or req.down_mbit:
        dev=get_host_veth(req.name)
        tc_limit(dev, req.up_mbit, req.down_mbit)

    audit("instance.create", req.model_dump())
    return {"ok":True,"name":req.name}

@app.post("/instances/{name}/limits")
def set_limits(name:str, req:LimitReq, _=Depends(require_panel)):
    if req.cpu_cores: run_lxc(["config","set",name,"limits.cpu",str(req.cpu_cores)])
    if req.cpu_limit_percent: run_lxc(["config","set",name,"limits.cpu.allowance",f"{req.cpu_limit_percent}%"])
    if req.memory_mb: run_lxc(["config","set",name,"limits.memory",f"{req.memory_mb}MB"])
    if req.disk_gb:
        try: run_lxc(["config","device","set",name,"root","size",f"{req.disk_gb}GB"])
        except HTTPException: pass
    if req.up_mbit or req.down_mbit:
        dev=get_host_veth(name)
        tc_limit(dev, req.up_mbit, req.down_mbit)
    audit("limits.set", {"name":name, **req.model_dump()})
    return {"ok":True}

@app.get("/ports")
def list_ports(_=Depends(require_panel)):
    ensure_port_rows()
    c=db()
    rows=c.execute("SELECT * FROM ports ORDER BY host_port").fetchall()
    c.close()
    return {"ports":[dict(r) for r in rows]}

@app.post("/instances/{name}/ports")
def add_port(name:str, req:PortMapReq, _=Depends(require_panel)):
    host_port = int(req.host_port) if req.host_port else allocate_port(name, req.container_port, req.proto)
    ip = get_inst_ipv4(name)
    dev_name=f"p{host_port}-{req.proto}"
    listen=f"{req.proto}:0.0.0.0:{host_port}"
    connect=f"{req.proto}:{ip}:{req.container_port}"

    try: run_lxc(["config","device","remove",name,dev_name])
    except HTTPException: pass
    run_lxc(["config","device","add",name,dev_name,"proxy",f"listen={listen}",f"connect={connect}"])
    audit("port.add", {"name":name,"host_port":host_port,"container_port":req.container_port,"proto":req.proto})
    return {"ok":True,"host_port":host_port,"container_ip":ip,"device":dev_name}

@app.delete("/instances/{name}/ports/{host_port}")
def del_port(name:str, host_port:int, _=Depends(require_panel)):
    for proto in ("tcp","udp"):
        dev_name=f"p{int(host_port)}-{proto}"
        try: run_lxc(["config","device","remove",name,dev_name])
        except HTTPException: pass
    release_port(int(host_port))
    audit("port.del", {"name":name,"host_port":int(host_port)})
    return {"ok":True}

@app.post("/instances/{name}/reinstall")
def reinstall(name:str, req:ReinstallReq, _=Depends(require_panel)):
    inst=lxc_json(["query", f"/1.0/instances/{name}"])
    config=inst.get("config",{})
    devices=inst.get("devices",{})
    profiles=inst.get("profiles",[DEFAULT_PROFILE])

    c=db()
    ports=c.execute("SELECT host_port,container_port,proto FROM ports WHERE in_use=1 AND container=?", (name,)).fetchall()
    c.close()

    try: run_lxc(["stop",name,"--force"], timeout=120)
    except HTTPException: pass
    run_lxc(["delete",name,"--force"], timeout=300)

    args=["launch", req.image, name]
    for p in profiles: args += ["-p", p]
    run_lxc(args, timeout=600)

    if req.preserve_limits:
        for k,v in config.items():
            if k.startswith("volatile."): continue
            try: run_lxc(["config","set",name,k,v])
            except HTTPException: pass

    for dev_name, dev in devices.items():
        if dev_name in ("eth0","root"): continue
        dtype=dev.get("type")
        if not dtype: continue
        cmd=["config","device","add",name,dev_name,dtype]
        for k,v in dev.items():
            if k=="type": continue
            cmd.append(f"{k}={v}")
        try: run_lxc(cmd)
        except HTTPException: pass

    if req.preserve_ports and ports:
        ip=get_inst_ipv4(name)
        for r in ports:
            hp=int(r["host_port"]); cp=int(r["container_port"]); proto=str(r["proto"] or "tcp")
            dev_name=f"p{hp}-{proto}"
            listen=f"{proto}:0.0.0.0:{hp}"
            connect=f"{proto}:{ip}:{cp}"
            try: run_lxc(["config","device","remove",name,dev_name])
            except HTTPException: pass
            run_lxc(["config","device","add",name,dev_name,"proxy",f"listen={listen}",f"connect={connect}"])

    audit("instance.reinstall", {"name":name, **req.model_dump()})
    return {"ok":True}

@app.post("/instances/{name}/users")
def create_linux_user(name:str, req:LinuxUserReq, _=Depends(require_panel)):
    try:
        run_lxc(["start", name], timeout=120)
    except HTTPException:
        pass

    u=req.username
    cmds=[]
    cmds.append(f"id -u {u} >/dev/null 2>&1 || useradd -m -s /bin/bash {u}")
    if req.password:
        cmds.append(f"printf '{u}:{req.password}' | chpasswd")
    if req.sudo:
        cmds.append(f"usermod -aG sudo {u} || true")
        cmds.append(f"echo '{u} ALL=(ALL) NOPASSWD:ALL' >/etc/sudoers.d/{u} && chmod 440 /etc/sudoers.d/{u}")
    if req.ssh_public_key:
        cmds.append(f"mkdir -p /home/{u}/.ssh && chmod 700 /home/{u}/.ssh")
        cmds.append(f"grep -qxF '{req.ssh_public_key}' /home/{u}/.ssh/authorized_keys 2>/dev/null || echo '{req.ssh_public_key}' >> /home/{u}/.ssh/authorized_keys")
        cmds.append(f"chmod 600 /home/{u}/.ssh/authorized_keys")
        cmds.append(f"chown -R {u}:{u} /home/{u}/.ssh")

    script=" && ".join(cmds)
    run_lxc(["exec", name, "--", "bash", "-lc", script], timeout=180)
    audit("linux_user.create", {"name":name, "username":u, "sudo":req.sudo, "has_ssh_key": bool(req.ssh_public_key)})
    return {"ok":True, "username":u}
PY
  ok "Node-Agent 代码写入完成"
}

node_setup_venv() {
  info "安装 Node-Agent Python 依赖..."
  python3 -m venv "${NODE_DIR}/venv"
  "${NODE_DIR}/venv/bin/pip" install --upgrade pip >/dev/null
  "${NODE_DIR}/venv/bin/pip" install -r "${NODE_DIR}/requirements.txt" >/dev/null
  ok "Node-Agent 依赖安装完成"
}

node_enroll_and_write_env() {
  local panel_url pair_token node_name node_url ip resp node_id node_secret lxd_sock
  read -r -p "请输入 Panel URL（例如 http://1.2.3.4:${PANEL_API_PORT}）: " panel_url
  read -r -p "请输入 Pair Token（在 Panel 生成）: " pair_token
  [[ -n "$panel_url" && -n "$pair_token" ]] || die "Panel URL / Pair Token 不能为空"

  node_name="$(hostname -s 2>/dev/null || echo node)"
  ip="$(host_ip)"
  node_url="http://${ip}:${NODE_PORT}"
  lxd_sock="$(detect_lxd_socket)"

  info "向 Panel enroll 注册节点..."
  resp="$(curl -sS "${panel_url%/}/nodes/enroll" \
    -H 'Content-Type: application/json' \
    -d "{\"token\":\"${pair_token}\",\"name\":\"${node_name}\",\"url\":\"${node_url}\"}")" || true

  node_id="$(echo "$resp" | jq -r '.node_id // empty')"
  node_secret="$(echo "$resp" | jq -r '.node_secret // empty')"
  [[ -n "$node_id" && -n "$node_secret" ]] || die "Enroll 失败：$resp"

  cat > "${CFG_DIR}/node.env" << EOF
NODE_DB=${DATA_DIR}/node.db
NODE_ID=${node_id}
NODE_SECRET=${node_secret}

NODE_PORT_MIN=${PORT_MIN}
NODE_PORT_MAX=${PORT_MAX}
NODE_DEFAULT_PROFILE=${DEFAULT_PROFILE}
EOF
  chmod 600 "${CFG_DIR}/node.env"
  echo "$node_id" > "${CFG_DIR}/node.id"; chmod 600 "${CFG_DIR}/node.id"
  echo "${node_url}" > "${CFG_DIR}/node.url"; chmod 600 "${CFG_DIR}/node.url"
  echo "${panel_url%/}" > "${CFG_DIR}/node.panel_url"; chmod 600 "${CFG_DIR}/node.panel_url"

  ok "节点已注册：node_id=${node_id}"
  ok "Node-Agent 将监听：${node_url}"
  warn "强烈建议：Panel/Node 之间走内网/VPN 或 mTLS 反代"
}

node_systemd() {
  info "注册 Node-Agent systemd..."
  cat > "/etc/systemd/system/${NODE_SERVICE}.service" << EOF
[Unit]
Description=LXD Node-Agent v2 (LXD host)
After=network.target lxd.service
Wants=lxd.service

[Service]
Type=simple
EnvironmentFile=${CFG_DIR}/node.env
WorkingDirectory=${NODE_DIR}
ExecStart=${NODE_DIR}/venv/bin/uvicorn app.main:app --host ${NODE_BIND_ADDR} --port ${NODE_PORT} --proxy-headers
Restart=always
RestartSec=2
User=root
NoNewPrivileges=true
PrivateTmp=true
ProtectHome=true
ProtectSystem=full
ReadWritePaths=${DATA_DIR} ${LOG_DIR} ${CFG_DIR} ${NODE_DIR}

[Install]
WantedBy=multi-user.target
EOF

  systemctl daemon-reload
  systemctl enable "${NODE_SERVICE}" >/dev/null
  systemctl restart "${NODE_SERVICE}"
  ok "Node-Agent 服务已启动：${NODE_SERVICE}"
}

node_install_and_enroll() {
  install_pkgs_common
  ensure_dirs

  install_lxd_if_needed
  init_lxd_if_needed

  mkdir -p "${NODE_DIR}"
  write_node_app
  node_setup_venv

  node_enroll_and_write_env
  node_systemd

  systemctl is-active --quiet "${NODE_SERVICE}" && ok "Node-Agent 安装成功" || warn "Node-Agent 服务未正常运行"
  node_show_info
}

node_show_info() {
  local ip node_id node_url panel_url
  ip="$(host_ip)"
  node_id="$(cat "${CFG_DIR}/node.id" 2>/dev/null || true)"
  node_url="$(cat "${CFG_DIR}/node.url" 2>/dev/null || echo "http://${ip}:${NODE_PORT}")"
  panel_url="$(cat "${CFG_DIR}/node.panel_url" 2>/dev/null || true)"

  echo -e "\n${GREEN}================= Node 对接信息 =================${PLAIN}"
  echo -e "Node-Agent URL: ${BLUE}${node_url}${PLAIN}"
  echo -e "Node ID       : ${YELLOW}${node_id:-未注册}${PLAIN}"
  echo -e "Panel URL     : ${YELLOW}${panel_url:-未知}${PLAIN}"
  echo -e "\n注意：Node-Agent 默认不对外开放给前端，建议只让 Panel 访问。"
  echo -e "Panel 侧调用示例："
  cat << EOF
  # 先在 Panel 上登录拿 JWT：TOKEN=...
  # 然后通过 Panel 代理请求此节点：
  curl -s ${panel_url:-http://PANEL_IP:${PANEL_API_PORT}}/nodes/${node_id:-NODE_ID}/instances \\
    -H "Authorization: Bearer \$TOKEN" | jq
EOF
  echo -e "${GREEN}=================================================${PLAIN}\n"

  # 本机自检（仅确认监听，不暴露 secret）
  echo "监听检查：ss -lntp | grep -E '(:${NODE_PORT}|uvicorn)' || true"
}

node_uninstall() {
  warn "卸载 Node-Agent..."
  read -r -p "是否保留数据（node.db/日志）？[y/N]: " keep
  keep="${keep:-N}"

  systemctl stop "${NODE_SERVICE}" >/dev/null 2>&1 || true
  systemctl disable "${NODE_SERVICE}" >/dev/null 2>&1 || true
  rm -f "/etc/systemd/system/${NODE_SERVICE}.service"
  systemctl daemon-reload

  rm -rf "${NODE_DIR}" || true
  rm -f "${CFG_DIR}/node.env" "${CFG_DIR}/node.id" "${CFG_DIR}/node.url" "${CFG_DIR}/node.panel_url" || true

  if [[ "${keep}" =~ ^[Yy]$ ]]; then
    ok "已卸载 Node-Agent（保留数据：${DATA_DIR} / ${LOG_DIR}）"
  else
    # 注意：这里会把 panel.db 一起删掉（如果同机装了 Panel）。因此只删 node.db 更稳。
    # 采用“只删 node.db”的策略。
    rm -f "${DATA_DIR}/node.db" || true
    ok "已卸载 Node-Agent（node.db 已清理；panel.db 未动）"
  fi
}

# ==============================================================================
# Pair Token helper (Panel side)
# ==============================================================================
panel_create_pair_token() {
  local ip admin_pass ttl token resp
  ip="$(host_ip)"

  [[ -f "${CFG_DIR}/panel.admin.pass" ]] || die "找不到 ${CFG_DIR}/panel.admin.pass（请先安装 Panel）"
  admin_pass="$(cat "${CFG_DIR}/panel.admin.pass")"

  read -r -p "Pair Token 有效期秒数（60~3600，默认600）: " ttl
  ttl="${ttl:-600}"

  # login -> token
  token="$(curl -s "http://${ip}:${PANEL_API_PORT}/auth/login" \
    -H 'Content-Type: application/json' \
    -d "{\"username\":\"admin\",\"password\":\"${admin_pass}\"}" | jq -r .token)"

  [[ -n "$token" && "$token" != "null" ]] || die "登录失败：请检查 Panel 是否运行 / 密码是否正确"

  resp="$(curl -s "http://${ip}:${PANEL_API_PORT}/nodes/pair_token?ttl_seconds=${ttl}" \
    -H "Authorization: Bearer ${token}")"

  echo -e "\n${GREEN}================= Pair Token =================${PLAIN}"
  echo "$resp" | jq
  echo -e "\n把上面的 token 粘到节点机上执行：菜单 4（安装 Node 并对接）"
  echo -e "${GREEN}==============================================${PLAIN}\n"
}

# ==============================================================================
# Menu
# ==============================================================================
menu() {
  echo -e "${GREEN}
================= LXD Panel v2 菜单 =================
1) 安装 Panel 后端（中心端）
2) 显示 Panel 对接 API
3) 生成节点配对 Token（pair_token）
4) 安装 Node-Agent 并对接到 Panel（enroll）
5) 显示 Node 对接信息
6) 卸载 Panel（可选保留数据）
7) 卸载 Node-Agent（可选保留数据）
0) 退出
=====================================================
${PLAIN}"
  read -r -p "请选择 [0-7]: " choice
  case "${choice}" in
    1) panel_install ;;
    2) panel_show_api ;;
    3) panel_create_pair_token ;;
    4) node_install_and_enroll ;;
    5) node_show_info ;;
    6) panel_uninstall ;;
    7) node_uninstall ;;
    0) exit 0 ;;
    *) warn "无效选项" ;;
  esac
}

# ==============================================================================
# Entry
# ==============================================================================
ensure_dirs
menu
