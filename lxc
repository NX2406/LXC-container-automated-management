#!/bin/bash
set -euo pipefail

RED='\033[0;31m'; GREEN='\033[0;32m'; YELLOW='\033[0;33m'; BLUE='\033[0;36m'; PLAIN='\033[0m'
info(){ echo -e "${BLUE}[INFO]${PLAIN} $*"; }
ok(){ echo -e "${GREEN}[OK]${PLAIN} $*"; }
warn(){ echo -e "${YELLOW}[WARN]${PLAIN} $*"; }
err(){ echo -e "${RED}[ERR]${PLAIN} $*"; }

[[ $EUID -eq 0 ]] || { err "请用 root 运行"; exit 1; }
export DEBIAN_FRONTEND=noninteractive

APP="lxd-panel-v2"
APP_DIR="/opt/${APP}"
CFG_DIR="/etc/${APP}"
DATA_DIR="/var/lib/${APP}"
SVC="${APP}.service"

PORT="${PORT:-9876}"
ADMIN_USER="${ADMIN_USER:-admin}"

rand_pw(){ tr -dc 'A-Za-z0-9_@#%+=' </dev/urandom | head -c "${1:-18}"; }
host_ip(){
  local ip
  ip="$(hostname -I 2>/dev/null | awk '{print $1}' || true)"
  [[ -z "$ip" ]] && ip="127.0.0.1"
  echo "$ip"
}
installed(){
  [[ -f "${CFG_DIR}/config.json" ]] && systemctl list-unit-files | grep -q "^${APP}.service"
}

install_deps(){
  info "安装系统依赖..."
  apt-get update -y
  apt-get install -y ca-certificates curl jq sqlite3 python3 python3-venv python3-pip iproute2
  ok "系统依赖安装完成"
}

install_lxd(){
  if command -v lxc >/dev/null 2>&1; then
    ok "LXD 已存在：$(lxc --version 2>/dev/null || true)"
    return
  fi
  info "安装 LXD（apt 版）..."
  apt-get install -y lxd lxd-client
  ok "LXD 安装完成"
  info "初始化 LXD（如已初始化会跳过）..."
  if ! lxc info >/dev/null 2>&1; then
    lxd init --auto || true
  fi
  ok "LXD 初始化完成"
}

write_backend(){
  info "写入后端代码..."
  mkdir -p "$APP_DIR" "$CFG_DIR" "$DATA_DIR"

  if [[ ! -f "${CFG_DIR}/config.json" ]]; then
    local pw
    pw="$(rand_pw 20)"
    cat > "${CFG_DIR}/config.json" <<EOF
{
  "listen_host": "0.0.0.0",
  "listen_port": ${PORT},
  "admin_user": "${ADMIN_USER}",
  "admin_pass": "${pw}",
  "token_ttl_seconds": 3600,
  "node_id": "local",
  "node_name": "local-node",
  "node_url": "lxd://local"
}
EOF
    chmod 600 "${CFG_DIR}/config.json"
  fi

  cat > "${APP_DIR}/requirements.txt" <<'REQ'
fastapi==0.115.0
uvicorn[standard]==0.30.6
pydantic==2.8.2
REQ

  cat > "${APP_DIR}/app.py" <<'PY'
import json, time, secrets, subprocess
from pathlib import Path
from fastapi import FastAPI, HTTPException, Header
from pydantic import BaseModel

CFG_PATH = Path("/etc/lxd-panel-v2/config.json")
cfg = json.loads(CFG_PATH.read_text())

app = FastAPI(title="LXD Panel Backend", version="2.0")

TOKENS = {}  # token -> exp

def sh(cmd):
  p = subprocess.run(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)
  if p.returncode != 0:
    raise HTTPException(500, detail=f"cmd failed: {' '.join(cmd)}\n{p.stderr.strip()}")
  return p.stdout.strip()

def auth(authorization: str | None):
  if not authorization or not authorization.startswith("Bearer "):
    raise HTTPException(401, detail="missing bearer token")
  token = authorization.split(" ",1)[1].strip()
  exp = TOKENS.get(token)
  if not exp or exp < time.time():
    raise HTTPException(401, detail="token expired")
  return True

class LoginIn(BaseModel):
  username: str
  password: str

class CreateInstanceIn(BaseModel):
  name: str
  image: str = "images:ubuntu/22.04"
  cpu_cores: int | None = None
  cpu_limit_percent: int | None = None
  memory_mb: int | None = None
  disk_gb: int | None = None
  up_mbit: int | None = None
  down_mbit: int | None = None

class PortAddIn(BaseModel):
  container_port: int
  proto: str = "tcp"
  host_port: int | None = None

class LimitsIn(BaseModel):
  cpu_cores: int | None = None
  cpu_limit_percent: int | None = None
  memory_mb: int | None = None
  disk_gb: int | None = None
  up_mbit: int | None = None
  down_mbit: int | None = None

class ReinstallIn(BaseModel):
  image: str
  preserve_ports: bool = True
  preserve_limits: bool = True

@app.get("/health")
def health():
  return {"ok": True, "service": "lxd-panel-v2", "node": cfg["node_id"]}

@app.post("/auth/login")
def login(data: LoginIn):
  if data.username != cfg["admin_user"] or data.password != cfg["admin_pass"]:
    raise HTTPException(401, detail="bad credentials")
  token = secrets.token_urlsafe(32)
  TOKENS[token] = time.time() + int(cfg.get("token_ttl_seconds", 3600))
  return {"token": token, "expires_in": int(cfg.get("token_ttl_seconds", 3600))}

@app.get("/nodes")
def nodes(authorization: str | None = Header(default=None)):
  auth(authorization)
  return {"nodes": [{"id": cfg["node_id"], "name": cfg["node_name"], "url": cfg["node_url"]}]}

@app.post("/nodes/pair_token")
def pair_token(ttl_seconds: int = 600, authorization: str | None = Header(default=None)):
  auth(authorization)
  # 这里做一个最小实现：返回一次性 token（后续你要做 enroll/agent 再扩展）
  ttl = max(60, min(3600, int(ttl_seconds)))
  token = secrets.token_urlsafe(20)
  return {"token": token, "expires_in": ttl}

@app.get("/nodes/{node_id}/instances")
def list_instances(node_id: str, authorization: str | None = Header(default=None)):
  auth(authorization)
  if node_id != cfg["node_id"]:
    raise HTTPException(404, detail="unknown node")
  out = sh(["lxc","list","--format","json"])
  return {"instances": json.loads(out)}

@app.post("/nodes/{node_id}/instances")
def create_instance(node_id: str, data: CreateInstanceIn, authorization: str | None = Header(default=None)):
  auth(authorization)
  if node_id != cfg["node_id"]:
    raise HTTPException(404, detail="unknown node")
  # create
  sh(["lxc","launch", data.image, data.name])

  # cpu/mem/disk (最小可用，后续可继续增强为 profile)
  if data.cpu_cores:
    sh(["lxc","config","set",data.name,"limits.cpu",str(data.cpu_cores)])
  if data.memory_mb:
    sh(["lxc","config","set",data.name,"limits.memory",f"{data.memory_mb}MB"])
  if data.disk_gb:
    # 需要 storage pool 支持，做最小处理：尝试 root size
    try:
      sh(["lxc","config","device","set",data.name,"root","size",f"{data.disk_gb}GB"])
    except Exception:
      pass

  # bandwidth (需要 nic 名称，默认 eth0)
  if data.up_mbit:
    try: sh(["lxc","config","device","set",data.name,"eth0","limits.egress",f"{data.up_mbit}Mbit"])
    except Exception: pass
  if data.down_mbit:
    try: sh(["lxc","config","device","set",data.name,"eth0","limits.ingress",f"{data.down_mbit}Mbit"])
    except Exception: pass

  return {"ok": True, "name": data.name}

@app.get("/nodes/{node_id}/ports")
def ports_pool(node_id: str, authorization: str | None = Header(default=None)):
  auth(authorization)
  if node_id != cfg["node_id"]:
    raise HTTPException(404, detail="unknown node")
  # 简化：返回当前被占用的监听端口（用于“查看端口池”）
  out = sh(["bash","-lc","ss -lntH | awk '{print $4}' | sed 's/.*://g' | sort -n | uniq"])
  ports = [p for p in out.splitlines() if p.strip().isdigit()]
  return {"listening_ports": ports, "count": len(ports)}

@app.post("/nodes/{node_id}/instances/{name}/ports")
def port_add(node_id: str, name: str, data: PortAddIn, authorization: str | None = Header(default=None)):
  auth(authorization)
  if node_id != cfg["node_id"]:
    raise HTTPException(404, detail="unknown node")
  proto = "tcp" if data.proto.lower()!="udp" else "udp"
  # auto host port
  host_port = data.host_port
  if not host_port:
    # pick a random port in 20000-40000 not listening
    used = set(int(p) for p in sh(["bash","-lc","ss -lntH | awk '{print $4}' | sed 's/.*://g' | sort -n | uniq"]).splitlines() if p.isdigit())
    for p in range(20000, 40001):
      if p not in used:
        host_port = p
        break
  dev = f"proxy{host_port}"
  # lxd proxy device
  sh(["lxc","config","device","add",name,dev,"proxy",f"listen={proto}:0.0.0.0:{host_port}",f"connect={proto}:127.0.0.1:{data.container_port}"])
  return {"ok": True, "host_port": host_port, "container_port": data.container_port, "proto": proto}

@app.delete("/nodes/{node_id}/instances/{name}/ports/{host_port}")
def port_del(node_id: str, name: str, host_port: int, authorization: str | None = Header(default=None)):
  auth(authorization)
  if node_id != cfg["node_id"]:
    raise HTTPException(404, detail="unknown node")
  dev = f"proxy{host_port}"
  sh(["lxc","config","device","remove",name,dev])
  return {"ok": True}

@app.post("/nodes/{node_id}/instances/{name}/limits")
def set_limits(node_id: str, name: str, data: LimitsIn, authorization: str | None = Header(default=None)):
  auth(authorization)
  if node_id != cfg["node_id"]:
    raise HTTPException(404, detail="unknown node")
  if data.cpu_cores:
    sh(["lxc","config","set",name,"limits.cpu",str(data.cpu_cores)])
  if data.memory_mb:
    sh(["lxc","config","set",name,"limits.memory",f"{data.memory_mb}MB"])
  if data.disk_gb:
    try: sh(["lxc","config","device","set",name,"root","size",f"{data.disk_gb}GB"])
    except Exception: pass
  if data.up_mbit:
    try: sh(["lxc","config","device","set",name,"eth0","limits.egress",f"{data.up_mbit}Mbit"])
    except Exception: pass
  if data.down_mbit:
    try: sh(["lxc","config","device","set",name,"eth0","limits.ingress",f"{data.down_mbit}Mbit"])
    except Exception: pass
  return {"ok": True}

@app.post("/nodes/{node_id}/instances/{name}/reinstall")
def reinstall(node_id: str, name: str, data: ReinstallIn, authorization: str | None = Header(default=None)):
  auth(authorization)
  if node_id != cfg["node_id"]:
    raise HTTPException(404, detail="unknown node")
  # 最小实现：delete + recreate （保留端口/limits 这里先不做复杂快照，后续可增强）
  sh(["lxc","stop",name,"--force"])
  sh(["lxc","delete",name])
  sh(["lxc","launch",data.image,name])
  return {"ok": True, "reinstalled": True, "image": data.image}
PY

  ok "后端代码写入完成"
}

install_python_env(){
  info "安装 Python 依赖..."
  python3 -m venv "${APP_DIR}/venv"
  "${APP_DIR}/venv/bin/pip" -q install --upgrade pip
  "${APP_DIR}/venv/bin/pip" -q install -r "${APP_DIR}/requirements.txt"
  ok "Python 依赖安装完成"
}

write_systemd(){
  info "写入 systemd 服务..."
  cat > "/etc/systemd/system/${APP}.service" <<EOF
[Unit]
Description=LXD Panel Backend v2
After=network-online.target
Wants=network-online.target

[Service]
Type=simple
WorkingDirectory=${APP_DIR}
ExecStart=${APP_DIR}/venv/bin/uvicorn app:app --host 0.0.0.0 --port ${PORT}
Restart=always
RestartSec=2
User=root
Environment=PYTHONUNBUFFERED=1

[Install]
WantedBy=multi-user.target
EOF

  systemctl daemon-reload
  systemctl enable "${APP}.service" >/dev/null
  systemctl restart "${APP}.service"
  ok "服务已启动：${APP}.service"
}

show_api(){
  if ! installed; then
    err "未检测到已安装的后端（缺少 ${CFG_DIR}/config.json 或 systemd 服务）"
    return 1
  fi
  local ip user pass
  ip="$(host_ip)"
  user="$(jq -r '.admin_user' "${CFG_DIR}/config.json")"
  pass="$(jq -r '.admin_pass' "${CFG_DIR}/config.json")"

  echo
  echo -e "${GREEN}==================== 后端对接信息 ====================${PLAIN}"
  echo -e "API Base : ${BLUE}http://${ip}:${PORT}${PLAIN}"
  echo -e "Health   : ${BLUE}http://${ip}:${PORT}/health${PLAIN}"
  echo -e "Admin    : ${YELLOW}${user}${PLAIN}"
  echo -e "Pass     : ${YELLOW}${pass}${PLAIN}"
  echo -e "${GREEN}======================================================${PLAIN}"
  echo
  ok "本机自检："
  curl -s "http://127.0.0.1:${PORT}/health" || true
  echo
}

uninstall_backend(){
  warn "开始卸载后端..."
  systemctl stop "${APP}.service" 2>/dev/null || true
  systemctl disable "${APP}.service" 2>/dev/null || true
  rm -f "/etc/systemd/system/${APP}.service"
  systemctl daemon-reload || true
  rm -rf "${APP_DIR}"
  rm -rf "${CFG_DIR}"
  rm -rf "${DATA_DIR}"
  ok "后端已卸载"
}

install_backend(){
  install_deps
  install_lxd
  write_backend
  install_python_env
  write_systemd

  # 强制验证：没起服务就直接报错，不让它“装完就退出”
  info "安装完成校验..."
  systemctl is-active --quiet "${APP}.service" || { systemctl status "${APP}.service" --no-pager -l || true; err "服务未启动"; exit 1; }
  ss -lntp | grep -q ":${PORT} " || { err "端口 ${PORT} 未监听"; exit 1; }
  curl -s "http://127.0.0.1:${PORT}/health" >/dev/null || { err "health 检查失败"; exit 1; }

  ok "后端安装+启动成功"
  show_api
}

menu(){
  clear
  echo -e "${GREEN}========== LXD Panel Backend v2 菜单 ==========${PLAIN}"
  echo "1) 安装后端"
  echo "2) 显示对接 API"
  echo "3) 卸载后端"
  echo "0) 退出"
  echo "============================================="
  read -rp "请选择: " c
  case "$c" in
    1) install_backend ;;
    2) show_api ;;
    3) uninstall_backend ;;
    0) exit 0 ;;
    *) echo "无效选择";;
  esac
}

while true; do
  menu
  read -rp "回车继续..." _
done
